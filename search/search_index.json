{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Vu Tang's Docs Site * Quote by Paulo Coelho , the author of \"The Alchemist\" This documentation was built by Mkdocs. For information please see at About me . Document Tree General Technote Mkdocs Tool : User guide how to use Github Page to publish a page with Mkdocs. Markdown Language : Markdown syntax what is used in this document Books Materials Notes when reading books or some materials Embedded Linux System Development Version Control : Introduction to Version Control and popular version control. Makefile : Definition Syntax Linux Device Driver Overview about LDD. SPI Driver Developement. FPGA Static Timing Analysis : basic deffinition and STA in Xilinx Vivado. Projects Zedboard : projects are implemented in zedboard platform. Document Rules Suitable picture size is: 300x200. Use GIMP for scaling figure (Folow instructions in Photos/ResizingPhotos from help.ubuntu.com). This document is writen in both Vietnamese and English.","title":"Preface"},{"location":"#welcome-to-vu-tangs-docs-site","text":"* Quote by Paulo Coelho , the author of \"The Alchemist\" This documentation was built by Mkdocs. For information please see at About me .","title":"Welcome to Vu Tang's Docs Site"},{"location":"#document-tree","text":"","title":"Document Tree"},{"location":"#general-technote","text":"Mkdocs Tool : User guide how to use Github Page to publish a page with Mkdocs. Markdown Language : Markdown syntax what is used in this document","title":"General Technote"},{"location":"#books-materials","text":"Notes when reading books or some materials","title":"Books &amp; Materials"},{"location":"#embedded-linux-system-development","text":"Version Control : Introduction to Version Control and popular version control. Makefile : Definition Syntax","title":"Embedded Linux System Development"},{"location":"#linux-device-driver","text":"Overview about LDD. SPI Driver Developement.","title":"Linux Device Driver"},{"location":"#fpga","text":"Static Timing Analysis : basic deffinition and STA in Xilinx Vivado.","title":"FPGA"},{"location":"#projects","text":"Zedboard : projects are implemented in zedboard platform.","title":"Projects"},{"location":"#document-rules","text":"Suitable picture size is: 300x200. Use GIMP for scaling figure (Folow instructions in Photos/ResizingPhotos from help.ubuntu.com). This document is writen in both Vietnamese and English.","title":"Document Rules"},{"location":"whatnext/","text":"To do Documentation: Markdown, Mkdocs, YAML Consider which online storage service will be used (Google drive or One drive) Update notes in one drive Coding and Algorithm: Reading books Hacker Rank Learning Python from Codecademy Linux Linux Device Driver: platform device, spi/i2c device, ethernet device Books","title":"What's next"},{"location":"whatnext/#to-do","text":"Documentation: Markdown, Mkdocs, YAML Consider which online storage service will be used (Google drive or One drive) Update notes in one drive Coding and Algorithm: Reading books Hacker Rank Learning Python from Codecademy Linux Linux Device Driver: platform device, spi/i2c device, ethernet device","title":"To do"},{"location":"whatnext/#books","text":"","title":"Books"},{"location":"about/about/","text":"Personal information Vu Tang Linked in: https://linkedin.com/in/vu-tang Embedded Software Engineer at Viettel Network Technologies Center Contact Email:","title":"About me"},{"location":"about/about/#personal-information","text":"Vu Tang Linked in: https://linkedin.com/in/vu-tang Embedded Software Engineer at Viettel Network Technologies Center","title":"Personal information"},{"location":"about/about/#contact","text":"Email:","title":"Contact"},{"location":"bookmarks/bookmarks/","text":"Linux website The Linux Foundation - https://www.linuxfoundation.org/ The Linux Document Project - http://wiki.tldp.org/ https://lwn.net/ Blogs Sciences Technologies in the World - Blogs of Prof. John Vu, Carnegie Mellon University. \"Journey to the East\" translator (Nguyen Phong). This page is useful to learning English. Shichao's Notes - I found the idea to create this documatation from this page. Tutorial Series on Linux Device Driver - EmbeTronicX In this docs, technical skills such as: muxtex, spinlock, workqueue have been introduced. Linux Device Drivers Series - OpenSourceForU.com Materials The Linux Kernel Documentation Course Computer Science: Algorithms, Theory, and Machines - Coursera Compyter Science Path - Codecademy Learning about Python Language","title":"Bookmarks"},{"location":"bookmarks/bookmarks/#linux-website","text":"The Linux Foundation - https://www.linuxfoundation.org/ The Linux Document Project - http://wiki.tldp.org/ https://lwn.net/","title":"Linux website"},{"location":"bookmarks/bookmarks/#blogs","text":"Sciences Technologies in the World - Blogs of Prof. John Vu, Carnegie Mellon University. \"Journey to the East\" translator (Nguyen Phong). This page is useful to learning English. Shichao's Notes - I found the idea to create this documatation from this page.","title":"Blogs"},{"location":"bookmarks/bookmarks/#tutorial","text":"Series on Linux Device Driver - EmbeTronicX In this docs, technical skills such as: muxtex, spinlock, workqueue have been introduced. Linux Device Drivers Series - OpenSourceForU.com","title":"Tutorial"},{"location":"bookmarks/bookmarks/#materials","text":"The Linux Kernel Documentation","title":"Materials"},{"location":"bookmarks/bookmarks/#course","text":"Computer Science: Algorithms, Theory, and Machines - Coursera Compyter Science Path - Codecademy Learning about Python Language","title":"Course"},{"location":"books/ldd3/","text":"This is note for LDD3","title":"Linux Device Driver"},{"location":"books/utlk/","text":"This note for Understanding The Linux Kernel","title":"Understanding Linux Kernel"},{"location":"fpga/timing_analysis/timing_analysis/","text":"STATIC TIMING ANALYSIS (STA) Hanoi Friday, September 22, 2016 -- by VuTang Static timing analysis (STA) is a simulation method of computing the expected timing of a digital circuit without requiring a simulation of the full circuit ( Wiki ). More information about STA in Vietnamese at T\u00ecm hi\u1ec3u v\u1ec1 Static Timing Analysis . Basic knowledge Definitions Clock Signal Clock l\u00e0 m\u1ed9t t\u00edn hi\u1ec7u c\u00f3 chu k\u00ec c\u00f3 c\u00e1c thu\u1ed9c t\u00ednh sau: Period (Chu k\u00ec), Duty Cycle, Jitter, Phase... M\u1ed9t s\u1ed1 \u0111\u1eb7c t\u00ednh \u0111\u00e1ng ch\u00fa \u00fd c\u1ee7a clock xu\u1ea5t hi\u1ec7n trong h\u1ec7 th\u1ed1ng th\u1ef1c t\u1ebf: Clock Skew: l\u00e0 hi\u1ec7n t\u01b0\u1ee3ng m\u00e0 trong m\u1ed9t m\u1ea1ch \u0111\u1ed3ng b\u1ed9 (asynchronous circuit) v\u1edbi c\u00f9ng m\u1ed9t ngu\u1ed3n clock \u0111\u1ea7u v\u00e0o nh\u01b0ng \u0111\u1ebfn c\u00e1c ph\u1ea7n t\u1eed Flip Flop (Clocked Element) kh\u00e1c nhau trong nh\u1eefng th\u1eddi \u0111i\u1ec3m kh\u00e1c nhau. Clock Jitter: l\u00e0 \u0111\u1ed9 l\u1ec7ch c\u1ee7a s\u01b0\u1eddn clock th\u1ef1c t\u1ebf so v\u1edbi s\u01b0\u1eddn clock l\u00ed t\u01b0\u1edfng. C\u00f3 nhi\u1ec1u lo\u1ea1i Jitter kh\u00e1c nhau nh\u01b0: Cycle-to-Cycle (\u0111\u1ed9 ch\u00eanh l\u1ec7ch gi\u1eefa hai chu k\u00ec li\u00ean ti\u1ebfp), Period (s\u1ef1 thay \u0111\u1ed5i l\u1edbn nh\u1ea5t c\u1ee7a chu k\u00ec clock trong v\u00f2ng 100 chu k\u00ec - cycles) Clock Latency: L\u00e0 kho\u1ea3ng th\u1eddi gian tr\u1ec5 t\u1eeb ngu\u1ed3n clock (clk port, MMCM output pin, ...) \u0111\u1ec3 ph\u1ea7n t\u1eed d\u00f9ng clock \u0111\u00f3 (clocked element). Synchronous/Asynchronous Clock: N\u1ebfu 2 clocks \u0111\u01b0\u1ee3c t\u1ea1o ra b\u1edfi 2 ngu\u1ed3n kh\u00e1c nhau th\u00ec \u0111\u01b0\u1ee3c m\u1eb7c \u0111\u1ecbnh l\u00e0 kh\u00f4ng \u0111\u1ed3ng b\u1ed9 (asynchronous) k\u1ec3 c\u1ea3 trong tr\u01b0\u1eddng h\u1ee3p l\u00e0 c\u00f9ng t\u1ea7n s\u1ed1. Nguy\u00ean nh\u00e2n: hai ngu\u1ed3n clocks kh\u00e1c nhau s\u1eed d\u1ee5ng c\u00e1c b\u1ed9 oscillator kh\u00e1c nhau, c\u00e1c b\u1ed9 oscillator n\u00e0y c\u00f3 \u0111\u1ed9 sai l\u1ec7ch theo th\u1eddi gian kh\u00e1c nhau n\u00ean d\u1eabn \u0111\u1ebfn quan h\u1ec7 phase v\u00e0 period gi\u1eefa hai clock kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ed1 \u0111\u1ecbnh (sai l\u1ec7ch c\u1ee7a b\u1ed9 oscillator \u0111\u01b0\u1ee3c \u0111o b\u1eb1ng ppm -- parts per million ho\u1eb7c ppb -- parts per billion ) N\u1ebfu 2 clocks \u0111\u01b0\u1ee3c t\u1ea1o ra t\u1eeb m\u1ed9t ngu\u1ed3n, m\u1eb7c d\u00f9 c\u00f3 th\u1ec3 phase v\u00e0 frequency kh\u00e1c nhau nh\u01b0ng v\u1eabn \u0111\u01b0\u1ee3c x\u00e9t l\u00e0 \u0111\u1ed3ng b\u1ed9. Setup/Hold Time Setup/Hold Time: X\u00e9t m\u1ed9t Flip Flop c\u00f3 ch\u00e2n clock CLK, data in D, data out Q. \u0110\u1ecbnh ngh\u0129a v\u1ec1 Setup/Hold Time \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n trong h\u00ecnh v\u1ebd sau: V\u1ec1 c\u01a1 b\u1ea3n, \u0111\u1ec3 m\u1ed9t Flip Flop ho\u1ea1t \u0111\u1ed9ng \u0111\u00fang ch\u1ee9c n\u0103ng, d\u1eef li\u1ec7u \u0111\u01b0a v\u00e0o \u0111\u1ea7u v\u00e0o D ph\u1ea3i th\u1ecfa m\u00e3n \u0111i\u1ec1u ki\u1ec7n Setup Time v\u00e0 Hold Time. Trong \u0111\u00f3, Setup Time l\u00e0 kho\u1ea3ng th\u1eddi gian nh\u1ecf nh\u1ea5t m\u00e0 Data in ph\u1ea3i gi\u1eef \u1ed5n \u0111\u1ecbnh tr\u01b0\u1edbc th\u1eddi \u0111i\u1ec3m s\u01b0\u1eddn l\u00ean clock; Hold Time l\u00e0 kho\u1ea3ng th\u1eddi gian nh\u1ecf nh\u1ea5t m\u00e0 Data in ph\u1ea3i gi\u1eef \u1ed5n \u0111\u1ecbnh sau th\u1eddi \u0111i\u1ec3m s\u01b0\u1eddn l\u00ean clock. Setup/Hold Time Violation: Khi \u0111\u1ea7u v\u00e0o D vi ph\u1ea1m \u0111i\u1ec1u ki\u1ec7n Setup/Hold Time, k\u1ebft qu\u1ea3 \u0111\u1ea7u ra Q c\u00f3 th\u1ec3 x\u1ea3y ra m\u1ed9t trong c\u00e1c tr\u01b0\u1eddng h\u1ee3p \u1edf h\u00ecnh sau: Metastability Definition in Wiki Static Timing Path l\u00e0 m\u1ed9t path m\u00e0: B\u1eaft \u0111\u1ea7u t\u1eeb m\u1ed9t Clocked Element Truy\u1ec1n lan qua c\u00e1c ph\u1ea7n t\u1eed logic c\u0169ng nh\u01b0 d\u00e2y n\u1ed1i K\u1ebft th\u00fac t\u1ea1i m\u1ed9t Clocked Element Setup check/Hold check Basic definitions is used in Setup check/Hold check. Launch edge: Capture edge: Hold relationship: Setup relationship: Setup check: Checks that a change in a clocked element has time to propagate to other clocked elements before the next clock event. STA with Vivado Xilinx performance baselining \u0110\u1ec3 c\u00f3 th\u1ec3 ph\u00e2n t\u00edch m\u1ed9t design hi\u1ec7u qu\u1ea3, k\u0129 s\u01b0 c\u00f3 th\u1ec3 d\u1ef1a v\u00e0o baselining m\u00e0 Xilinx gi\u1edbi thi\u1ec7u. Chi ti\u1ebft v\u1ec1 c\u00e1c b\u01b0\u1edbc th\u1ef1c hi\u1ec7n ph\u00e2n t\u00edch theo Xilinx \u0111\u01b0\u1ee3c th\u1ec3 hi\u1ec7n trong c\u00e1c h\u00ecnh v\u1ebd sau. Trong \u0111\u00f3 c\u00f3 ba b\u01b0\u1edbc ch\u00ednh: Optimize Internal Paths: Ti\u1ebfn h\u00e0nh ph\u00e2n t\u00edch, t\u1ed1i \u01b0u n\u1ed9i b\u1ed9 FPGA. Optimize Entire Chip: Ti\u1ebfn h\u00e0nh ph\u00e2n t\u00edch to\u00e0n b\u1ed9 FPGA trong \u0111\u00f3 bao g\u1ed3m c\u1ea3 k\u1ebft n\u1ed1i n\u1ed9i b\u1ed9 c\u0169ng nh\u01b0 c\u00e1c k\u1ebft n\u1ed1i v\u1edbi chip b\u00ean ngo\u00e0i Fine-tune: B\u1ed5 sung th\u00eam c\u00e1c constraint li\u00ean quan \u0111\u1ebfn exception path, floor planning Trong b\u00e1o c\u00e1o n\u00e0y s\u1ebd t\u1eadp trung v\u00e0o m\u1ee5c Optimize Internal Path. Qu\u00e1 tr\u00ecnh n\u00e0y \u0111\u01b0\u1ee3c th\u1ec3 hi\u1ec7n tr\u00ean c\u00f4t d\u1ecdc th\u1ee9 nh\u1ea5t c\u1ee7a s\u01a1 \u0111\u1ed3. Xilinx timing analysis tool Vivado timing analysis report M\u1ed9t s\u1ed1 kh\u00e1i ni\u1ec7m c\u01a1 b\u1ea3n trong Xilinx Timing Report. Trong c\u00e1c timing report, th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n c\u00e1c kh\u00e1i ni\u1ec7m nh\u01b0 WNS/TNS, WHS/THS. C\u00e1c tham s\u1ed1 n\u00e0y \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u00e1nh gi\u00e1 m\u1ed9t design c\u00f3 timing violation hay kh\u00f4ng. \u0110\u1ecbnh ngh\u0129a c\u1ee7a c\u00e1c tham s\u1ed1 n\u00e0y nh\u01b0 sau: WNS: Worst Negative Slack . K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh Setup Check TNS: Total Negative Slack . T\u1ed5ng gi\u00e1 tr\u1ecb c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c Negative Slack WHS: Worst Hold Slack . K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh Hold Check. THS: Total Hold Slack . T\u1ed5ng gi\u00e1 tr\u1ecb c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c Hold Slack. How does Vivado calculate Hold Time Slack? Hold Time Check \u0111\u01b0\u1ee3c x\u00e9t tr\u00ean c\u00f9ng m\u1ed9t s\u01b0\u1eddn clock c\u1ee7a Source Clock v\u00e0 Destination Clock. X\u00e9t m\u1ed9t Static Timing Path c\u1ee5 th\u1ec3 c\u00f3 s\u01a1 \u0111\u1ed3 nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y. Timing path \u0111\u01b0\u1ee3c t\u00ednh gi\u1eefa F1 v\u00e0 F2 (2 Clocked Elements), F1/F2 s\u1eed d\u1ee5ng chung clocks \u0111\u01b0\u1ee3c l\u1ea5y t\u1eeb CLKOUT1 c\u1ee7a MMCM2_ADV. Chi ti\u1ebft v\u1ec1 path n\u00e0y \u0111\u01b0\u1ee3c ghi r\u00f5 trong report sau: \u1ede m\u1ee5c Summary c\u1ee7a Path Report c\u00f3 c\u00e1c th\u00f4ng tin sau: Name: T\u00ean c\u1ee7a path trong design Slack (Hold): Negative Hold Slack Source: Pin Clock in c\u1ee7a F1 Destination: Pin Data in c\u1ee7a F2 Path Group: group clock c\u1ee7a path \u0111ang \u0111\u01b0\u1ee3c x\u00e9t, \u1edf \u0111\u00e2y l\u00e0 generated clock ad9122_tx1_serdes_clkout1 Path Type: Lo\u1ea1i path \u0111ang \u0111\u01b0\u1ee3c x\u00e9t, Hold ho\u1eb7c Setup (???) Requirement: (???) Data Path Delay: Delay gi\u1eefa F1/F2. Trong tr\u01b0\u1eddng h\u1ee3p n\u00e0y, kh\u00f4ng c\u00f3 b\u1ea5t k\u00ec ph\u1ea7n t\u1eed logic n\u00e0o n\u1eb1m tr\u00ean path n\u00e0y, do \u0111\u00f3 Data Path Delay \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng t\u1ed5ng c\u1ee7a: FlipFlop Delay (th\u1eddi gian t\u1eeb khi c\u00f3 input \u0111\u1ebfn khi c\u00f3 output c\u1ee7a FF) v\u00e0 Net Delay (tr\u1ec5 tr\u00ean d\u00e2y n\u1ed1i). Logic Level: (Xem l\u1ea1i \u0111\u1ecbnh ngh\u0129a c\u1ee7a logic level) Clock Path Skew: \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng DCD-SCD-CPR trong \u0111\u00f3: DCD l\u00e0 Destination Clock Delay, SCD Source Clock Delay v\u00e0 CPR l\u00e0 Clock Pessimism Removal. Clock Pessimism Removal (CPR) is the removal of artificially induced pessimism from the common clock path between launching startpoint and capturing endpoint. \u1ede m\u1ee5c Source Clock Path, report s\u1ebd m\u00f4 t\u1ea3 chi ti\u1ebft \u0111\u01b0\u1eddng \u0111i c\u1ee7a Source Clock. Theo nh\u01b0 report \u1edf h\u00ecnh tr\u00ean, \u0111\u1ec3 \u0111\u1ebfn \u0111\u01b0\u1ee3c F1, Source Clock s\u1ebd ph\u1ea3i \u0111i qua: IBUFDS BUFG, PLL2_ADV BUFGCTL, MMCM2_ADV BUFG nh\u01b0 \u1edf h\u00ecnh v\u1ebd \u0111\u1ea7u ti\u00ean. Qua report ta r\u00fat ra \u0111\u01b0\u1ee3c m\u1ed9t s\u1ed1 nh\u1eadn x\u00e9t nh\u01b0 sau: Sau khi \u0111i qua c\u00e1c ph\u1ea7n t\u1eed nh\u01b0 BUFG, IBUFDS, BUFGCTL ..., clock b\u1ecb tr\u1ec5 \u0111i m\u1ed9t kho\u1ea3ng th\u1eddi gian Sau khi \u0111i qua c\u00e1c ph\u1ea7n t\u1eed t\u1ea1o clock nh\u01b0 MMCM2_ADV, PLL2_ADV..., t\u00f9y theo c\u1ea5u h\u00ecnh m\u00e0 clock c\u00f3 th\u1ec3 gi\u1ea3m ho\u1eb7c t\u0103ng \u0111\u1ed9 tr\u1ec5 (gi\u00e1 tr\u1ecb c\u00f3 th\u1ec3 \u00e2m ho\u1eb7c d\u01b0\u01a1ng). Ph\u1ea7n Data Path s\u1ebd m\u00f4 t\u1ea3 chi ti\u1ebft h\u01a1n v\u1ec1 delay gi\u1eefa F1/F2, c\u00e1i m\u00e0 \u0111\u00e3 \u0111\u01b0\u1ee3c nh\u1eafc \u0111\u1ebfn \u1edf m\u1ee5c Sumary. Ph\u1ea7n Destination Clock Path c\u00f3 ch\u1ee9c n\u0103ng t\u01b0\u01a1ng t\u1ef1 nh\u01b0 ph\u1ea7n Source Clock Path, s\u1ebd m\u00f4 t\u1ea3 chi ti\u1ebft \u0111\u01b0\u1eddng \u0111i c\u1ee7a Destination Clock Path. V\u1edbi Report nh\u01b0 tr\u00ean, ta c\u00f3 th\u1ec3 v\u1ebd \u0111\u01b0\u1ee3c Timing Diagram cho Path n\u00e0y nh\u01b0 sau: Trong \u0111\u00f3: Source Clock Path Delay b\u1eb1ng 0.975 ns \u0111\u01b0\u1ee3c t\u00ednh t\u1eeb t\u1ed5ng c\u00e1c delay tr\u00ean c\u00e1c ph\u1ea7n t\u1eed m\u00e0 clocks \u0111i qua, gi\u00e1 tr\u1ecb n\u00e0y c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c \u1edf d\u00f2ng cu\u1ed1i c\u00f9ng c\u1ee7a Source Clock Report. Data Path Delay b\u1eb1ng 0.424 ns l\u00e0 gi\u00e1 tr\u1ecb c\u1ee7a delay gi\u1eefa F1/F2, gi\u00e1 tr\u1ecb n\u00e0y c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c t\u1eeb d\u00f2ng cu\u1ed1i c\u00f9ng c\u1ee7a Data Path report. L\u01b0u \u00fd r\u1eb1ng gi\u00e1 tr\u1ecb \u0111\u1ecdc \u0111\u01b0\u1ee3c \u0111\u00e3 \u0111\u01b0\u1ee3c c\u1ed9ng th\u00eam Source Clock Path Delay. Destination Clock Path Delay b\u1eb1ng 1.559 ns \u0111\u01b0\u1ee3c t\u00ednh gi\u1ed1ng nh\u01b0 v\u1edbi Source Clock Path Delay. Gi\u00e1 tr\u1ecb Negative Hold Time Slack s\u1ebd \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng: Source Clock Path Delay + Data Path Delay -- Destination Clock Path Delay = 0.975 ns + 0.424 ns -- 1.559 ns = - 0.220 ns** K\u1ebft qu\u1ea3 n\u00e0y gi\u1ed1ng v\u1edbi Report c\u1ee7a Xilinx Vivado. How does Vivado calculate Setup Time Slack? Qu\u00e1 tr\u00ecnh t\u00ednh to\u00e1n Setup Time Slack \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n t\u01b0\u01a1ng t\u1ef1 nh\u01b0 Hold Time Slack nh\u01b0 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n tr\u00ean hai s\u01b0\u1eddn clock kh\u00e1c nhau. Timing Analysis TCL Command get_clocks Description: \u0110\u01b0\u1ee3c d\u00f9ng \u0111\u1ec3 list ra c\u00e1c clocks trong thi\u1ebft k\u1ebf hi\u1ec7n t\u1ea1i. Syntax: get_clocks [-regexp] [-nocase] [-filter arg ] [-of_objects args ] [-match_style arg ] [-include_generated_clocks] [-quiet] verbose] [ patterns ] Examples: get_clocks //getting all clocks in current design get_clock adc* // getting all clocks that has pattern \"adc\" in its name get_clock {adc* clk_out1*} // getting all clocks that has any pattern listed in {} in its name get_clocks -include_generated_clocks adc_clk_fwd // getting adc_clk_fwd and all of its generated clocks report_clocks Description: reporting about a clocks or a list of clocks Syntax: report_clocks [-file arg ] [-append] [-return_string] [-quiet] [-verbose] [ clocks ] Examples: report_clocks // reporting all clocks in current design report_clocks --file report_clock_evt2a.txt // reporting and then outputting this content to an output file. Create output file if it is not existed. report_clocks [get_clocks adc_clk_fwd] // reporting about particular clock that is gotten by using get_clocks command. Xilinx Design Constraint (XDC) Design with the 7 series Clocking Resources in 7 series. Clock regions: M\u1ed7i die FPGA \u0111\u01b0\u1ee3c chia th\u00e0nh c\u00e1c clock regions. Chi\u1ec1u cao (high) c\u1ee7a m\u1ed7i clock regions l\u00e0 50 CLBs (50 CLBs rows), b\u1ec1 r\u1ed9ng chi\u1ebfm m\u1ed9t n\u1eeda die. Clock Management Tile (CMT): M\u1ed7i clock region ch\u1ee9a m\u1ed9t CMT. Trong m\u1ed7i CMT ch\u1ee9a: 01 Mixed-Mode Clock Managers (MMCMs), 01 Phase Locked Loop (PLL). Clock-Capable Inputs (CCIO) : b\u1ea5t k\u00ec m\u1ed9t thi\u1ebft k\u1ebf FPGA \u0111\u1ed3ng b\u1ed9 n\u00e0o (synchronous design) \u0111\u1ec1u c\u1ea7n ph\u1ea3i cung c\u1ea5p \u00edt nh\u1ea5t m\u1ed9t \u0111\u01b0\u1eddng clock reference t\u1eeb b\u00ean ngo\u00e0i chip. \u0110\u01b0\u1eddng clock n\u00e0y s\u1ebd \u0111\u01b0\u1ee3c \u0111\u01b0a v\u00e0o chip FPGA b\u1eb1ng c\u00e1c port \u0111\u1eb7c bi\u1ec7t (clock-capable) \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf ri\u00eang cho clock. \u0110\u1ed1i v\u1edbi 7 series FPGA s\u1ebd c\u00f3 4 ports clock-capable. Trong \u0111\u00f3: 2 port l\u00e0 Multi-Region Clock Capable (MRCC), 2 ports c\u00f2n l\u1ea1i l\u00e0 Single Region Clock Capable (SRCC). IBUFG, IBUFGS c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 map t\u00edn hi\u1ec7u clock \u0111\u1ebfn c\u00e1c ch\u00e2n clock-capable. Global Clocking: Global clock networks cho pheps ph\u00e2n ph\u1ed1i clocks \u0111\u1ebfn c\u00e1c clocked element tr\u00ean chip die. Global clocks are driven by BUFGCTRL located in the middle of the die. Global Clocking Buffer (BUFGCTRL): For Clock Multiplexing - BUFGMUX For Gated Clock -- BUFGCE Horizontal Spine Clock Buffer (BUFH):","title":"Static Timing Analysis"},{"location":"fpga/timing_analysis/timing_analysis/#static-timing-analysis-sta","text":"Hanoi Friday, September 22, 2016 -- by VuTang Static timing analysis (STA) is a simulation method of computing the expected timing of a digital circuit without requiring a simulation of the full circuit ( Wiki ). More information about STA in Vietnamese at T\u00ecm hi\u1ec3u v\u1ec1 Static Timing Analysis .","title":"STATIC TIMING ANALYSIS (STA)"},{"location":"fpga/timing_analysis/timing_analysis/#basic-knowledge","text":"","title":"Basic knowledge"},{"location":"fpga/timing_analysis/timing_analysis/#definitions","text":"","title":"Definitions"},{"location":"fpga/timing_analysis/timing_analysis/#clock-signal","text":"Clock l\u00e0 m\u1ed9t t\u00edn hi\u1ec7u c\u00f3 chu k\u00ec c\u00f3 c\u00e1c thu\u1ed9c t\u00ednh sau: Period (Chu k\u00ec), Duty Cycle, Jitter, Phase... M\u1ed9t s\u1ed1 \u0111\u1eb7c t\u00ednh \u0111\u00e1ng ch\u00fa \u00fd c\u1ee7a clock xu\u1ea5t hi\u1ec7n trong h\u1ec7 th\u1ed1ng th\u1ef1c t\u1ebf: Clock Skew: l\u00e0 hi\u1ec7n t\u01b0\u1ee3ng m\u00e0 trong m\u1ed9t m\u1ea1ch \u0111\u1ed3ng b\u1ed9 (asynchronous circuit) v\u1edbi c\u00f9ng m\u1ed9t ngu\u1ed3n clock \u0111\u1ea7u v\u00e0o nh\u01b0ng \u0111\u1ebfn c\u00e1c ph\u1ea7n t\u1eed Flip Flop (Clocked Element) kh\u00e1c nhau trong nh\u1eefng th\u1eddi \u0111i\u1ec3m kh\u00e1c nhau. Clock Jitter: l\u00e0 \u0111\u1ed9 l\u1ec7ch c\u1ee7a s\u01b0\u1eddn clock th\u1ef1c t\u1ebf so v\u1edbi s\u01b0\u1eddn clock l\u00ed t\u01b0\u1edfng. C\u00f3 nhi\u1ec1u lo\u1ea1i Jitter kh\u00e1c nhau nh\u01b0: Cycle-to-Cycle (\u0111\u1ed9 ch\u00eanh l\u1ec7ch gi\u1eefa hai chu k\u00ec li\u00ean ti\u1ebfp), Period (s\u1ef1 thay \u0111\u1ed5i l\u1edbn nh\u1ea5t c\u1ee7a chu k\u00ec clock trong v\u00f2ng 100 chu k\u00ec - cycles) Clock Latency: L\u00e0 kho\u1ea3ng th\u1eddi gian tr\u1ec5 t\u1eeb ngu\u1ed3n clock (clk port, MMCM output pin, ...) \u0111\u1ec3 ph\u1ea7n t\u1eed d\u00f9ng clock \u0111\u00f3 (clocked element). Synchronous/Asynchronous Clock: N\u1ebfu 2 clocks \u0111\u01b0\u1ee3c t\u1ea1o ra b\u1edfi 2 ngu\u1ed3n kh\u00e1c nhau th\u00ec \u0111\u01b0\u1ee3c m\u1eb7c \u0111\u1ecbnh l\u00e0 kh\u00f4ng \u0111\u1ed3ng b\u1ed9 (asynchronous) k\u1ec3 c\u1ea3 trong tr\u01b0\u1eddng h\u1ee3p l\u00e0 c\u00f9ng t\u1ea7n s\u1ed1. Nguy\u00ean nh\u00e2n: hai ngu\u1ed3n clocks kh\u00e1c nhau s\u1eed d\u1ee5ng c\u00e1c b\u1ed9 oscillator kh\u00e1c nhau, c\u00e1c b\u1ed9 oscillator n\u00e0y c\u00f3 \u0111\u1ed9 sai l\u1ec7ch theo th\u1eddi gian kh\u00e1c nhau n\u00ean d\u1eabn \u0111\u1ebfn quan h\u1ec7 phase v\u00e0 period gi\u1eefa hai clock kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ed1 \u0111\u1ecbnh (sai l\u1ec7ch c\u1ee7a b\u1ed9 oscillator \u0111\u01b0\u1ee3c \u0111o b\u1eb1ng ppm -- parts per million ho\u1eb7c ppb -- parts per billion ) N\u1ebfu 2 clocks \u0111\u01b0\u1ee3c t\u1ea1o ra t\u1eeb m\u1ed9t ngu\u1ed3n, m\u1eb7c d\u00f9 c\u00f3 th\u1ec3 phase v\u00e0 frequency kh\u00e1c nhau nh\u01b0ng v\u1eabn \u0111\u01b0\u1ee3c x\u00e9t l\u00e0 \u0111\u1ed3ng b\u1ed9.","title":"Clock Signal"},{"location":"fpga/timing_analysis/timing_analysis/#setuphold-time","text":"Setup/Hold Time: X\u00e9t m\u1ed9t Flip Flop c\u00f3 ch\u00e2n clock CLK, data in D, data out Q. \u0110\u1ecbnh ngh\u0129a v\u1ec1 Setup/Hold Time \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n trong h\u00ecnh v\u1ebd sau: V\u1ec1 c\u01a1 b\u1ea3n, \u0111\u1ec3 m\u1ed9t Flip Flop ho\u1ea1t \u0111\u1ed9ng \u0111\u00fang ch\u1ee9c n\u0103ng, d\u1eef li\u1ec7u \u0111\u01b0a v\u00e0o \u0111\u1ea7u v\u00e0o D ph\u1ea3i th\u1ecfa m\u00e3n \u0111i\u1ec1u ki\u1ec7n Setup Time v\u00e0 Hold Time. Trong \u0111\u00f3, Setup Time l\u00e0 kho\u1ea3ng th\u1eddi gian nh\u1ecf nh\u1ea5t m\u00e0 Data in ph\u1ea3i gi\u1eef \u1ed5n \u0111\u1ecbnh tr\u01b0\u1edbc th\u1eddi \u0111i\u1ec3m s\u01b0\u1eddn l\u00ean clock; Hold Time l\u00e0 kho\u1ea3ng th\u1eddi gian nh\u1ecf nh\u1ea5t m\u00e0 Data in ph\u1ea3i gi\u1eef \u1ed5n \u0111\u1ecbnh sau th\u1eddi \u0111i\u1ec3m s\u01b0\u1eddn l\u00ean clock. Setup/Hold Time Violation: Khi \u0111\u1ea7u v\u00e0o D vi ph\u1ea1m \u0111i\u1ec1u ki\u1ec7n Setup/Hold Time, k\u1ebft qu\u1ea3 \u0111\u1ea7u ra Q c\u00f3 th\u1ec3 x\u1ea3y ra m\u1ed9t trong c\u00e1c tr\u01b0\u1eddng h\u1ee3p \u1edf h\u00ecnh sau: Metastability Definition in Wiki Static Timing Path l\u00e0 m\u1ed9t path m\u00e0: B\u1eaft \u0111\u1ea7u t\u1eeb m\u1ed9t Clocked Element Truy\u1ec1n lan qua c\u00e1c ph\u1ea7n t\u1eed logic c\u0169ng nh\u01b0 d\u00e2y n\u1ed1i K\u1ebft th\u00fac t\u1ea1i m\u1ed9t Clocked Element","title":"Setup/Hold Time"},{"location":"fpga/timing_analysis/timing_analysis/#setup-checkhold-check","text":"Basic definitions is used in Setup check/Hold check. Launch edge: Capture edge: Hold relationship: Setup relationship: Setup check: Checks that a change in a clocked element has time to propagate to other clocked elements before the next clock event.","title":"Setup check/Hold check"},{"location":"fpga/timing_analysis/timing_analysis/#sta-with-vivado","text":"","title":"STA with Vivado"},{"location":"fpga/timing_analysis/timing_analysis/#xilinx-performance-baselining","text":"\u0110\u1ec3 c\u00f3 th\u1ec3 ph\u00e2n t\u00edch m\u1ed9t design hi\u1ec7u qu\u1ea3, k\u0129 s\u01b0 c\u00f3 th\u1ec3 d\u1ef1a v\u00e0o baselining m\u00e0 Xilinx gi\u1edbi thi\u1ec7u. Chi ti\u1ebft v\u1ec1 c\u00e1c b\u01b0\u1edbc th\u1ef1c hi\u1ec7n ph\u00e2n t\u00edch theo Xilinx \u0111\u01b0\u1ee3c th\u1ec3 hi\u1ec7n trong c\u00e1c h\u00ecnh v\u1ebd sau. Trong \u0111\u00f3 c\u00f3 ba b\u01b0\u1edbc ch\u00ednh: Optimize Internal Paths: Ti\u1ebfn h\u00e0nh ph\u00e2n t\u00edch, t\u1ed1i \u01b0u n\u1ed9i b\u1ed9 FPGA. Optimize Entire Chip: Ti\u1ebfn h\u00e0nh ph\u00e2n t\u00edch to\u00e0n b\u1ed9 FPGA trong \u0111\u00f3 bao g\u1ed3m c\u1ea3 k\u1ebft n\u1ed1i n\u1ed9i b\u1ed9 c\u0169ng nh\u01b0 c\u00e1c k\u1ebft n\u1ed1i v\u1edbi chip b\u00ean ngo\u00e0i Fine-tune: B\u1ed5 sung th\u00eam c\u00e1c constraint li\u00ean quan \u0111\u1ebfn exception path, floor planning Trong b\u00e1o c\u00e1o n\u00e0y s\u1ebd t\u1eadp trung v\u00e0o m\u1ee5c Optimize Internal Path. Qu\u00e1 tr\u00ecnh n\u00e0y \u0111\u01b0\u1ee3c th\u1ec3 hi\u1ec7n tr\u00ean c\u00f4t d\u1ecdc th\u1ee9 nh\u1ea5t c\u1ee7a s\u01a1 \u0111\u1ed3.","title":"Xilinx performance baselining"},{"location":"fpga/timing_analysis/timing_analysis/#xilinx-timing-analysis-tool","text":"","title":"Xilinx timing analysis tool"},{"location":"fpga/timing_analysis/timing_analysis/#vivado-timing-analysis-report","text":"M\u1ed9t s\u1ed1 kh\u00e1i ni\u1ec7m c\u01a1 b\u1ea3n trong Xilinx Timing Report. Trong c\u00e1c timing report, th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n c\u00e1c kh\u00e1i ni\u1ec7m nh\u01b0 WNS/TNS, WHS/THS. C\u00e1c tham s\u1ed1 n\u00e0y \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u00e1nh gi\u00e1 m\u1ed9t design c\u00f3 timing violation hay kh\u00f4ng. \u0110\u1ecbnh ngh\u0129a c\u1ee7a c\u00e1c tham s\u1ed1 n\u00e0y nh\u01b0 sau: WNS: Worst Negative Slack . K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh Setup Check TNS: Total Negative Slack . T\u1ed5ng gi\u00e1 tr\u1ecb c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c Negative Slack WHS: Worst Hold Slack . K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh Hold Check. THS: Total Hold Slack . T\u1ed5ng gi\u00e1 tr\u1ecb c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c Hold Slack. How does Vivado calculate Hold Time Slack? Hold Time Check \u0111\u01b0\u1ee3c x\u00e9t tr\u00ean c\u00f9ng m\u1ed9t s\u01b0\u1eddn clock c\u1ee7a Source Clock v\u00e0 Destination Clock. X\u00e9t m\u1ed9t Static Timing Path c\u1ee5 th\u1ec3 c\u00f3 s\u01a1 \u0111\u1ed3 nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y. Timing path \u0111\u01b0\u1ee3c t\u00ednh gi\u1eefa F1 v\u00e0 F2 (2 Clocked Elements), F1/F2 s\u1eed d\u1ee5ng chung clocks \u0111\u01b0\u1ee3c l\u1ea5y t\u1eeb CLKOUT1 c\u1ee7a MMCM2_ADV. Chi ti\u1ebft v\u1ec1 path n\u00e0y \u0111\u01b0\u1ee3c ghi r\u00f5 trong report sau: \u1ede m\u1ee5c Summary c\u1ee7a Path Report c\u00f3 c\u00e1c th\u00f4ng tin sau: Name: T\u00ean c\u1ee7a path trong design Slack (Hold): Negative Hold Slack Source: Pin Clock in c\u1ee7a F1 Destination: Pin Data in c\u1ee7a F2 Path Group: group clock c\u1ee7a path \u0111ang \u0111\u01b0\u1ee3c x\u00e9t, \u1edf \u0111\u00e2y l\u00e0 generated clock ad9122_tx1_serdes_clkout1 Path Type: Lo\u1ea1i path \u0111ang \u0111\u01b0\u1ee3c x\u00e9t, Hold ho\u1eb7c Setup (???) Requirement: (???) Data Path Delay: Delay gi\u1eefa F1/F2. Trong tr\u01b0\u1eddng h\u1ee3p n\u00e0y, kh\u00f4ng c\u00f3 b\u1ea5t k\u00ec ph\u1ea7n t\u1eed logic n\u00e0o n\u1eb1m tr\u00ean path n\u00e0y, do \u0111\u00f3 Data Path Delay \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng t\u1ed5ng c\u1ee7a: FlipFlop Delay (th\u1eddi gian t\u1eeb khi c\u00f3 input \u0111\u1ebfn khi c\u00f3 output c\u1ee7a FF) v\u00e0 Net Delay (tr\u1ec5 tr\u00ean d\u00e2y n\u1ed1i). Logic Level: (Xem l\u1ea1i \u0111\u1ecbnh ngh\u0129a c\u1ee7a logic level) Clock Path Skew: \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng DCD-SCD-CPR trong \u0111\u00f3: DCD l\u00e0 Destination Clock Delay, SCD Source Clock Delay v\u00e0 CPR l\u00e0 Clock Pessimism Removal. Clock Pessimism Removal (CPR) is the removal of artificially induced pessimism from the common clock path between launching startpoint and capturing endpoint. \u1ede m\u1ee5c Source Clock Path, report s\u1ebd m\u00f4 t\u1ea3 chi ti\u1ebft \u0111\u01b0\u1eddng \u0111i c\u1ee7a Source Clock. Theo nh\u01b0 report \u1edf h\u00ecnh tr\u00ean, \u0111\u1ec3 \u0111\u1ebfn \u0111\u01b0\u1ee3c F1, Source Clock s\u1ebd ph\u1ea3i \u0111i qua: IBUFDS BUFG, PLL2_ADV BUFGCTL, MMCM2_ADV BUFG nh\u01b0 \u1edf h\u00ecnh v\u1ebd \u0111\u1ea7u ti\u00ean. Qua report ta r\u00fat ra \u0111\u01b0\u1ee3c m\u1ed9t s\u1ed1 nh\u1eadn x\u00e9t nh\u01b0 sau: Sau khi \u0111i qua c\u00e1c ph\u1ea7n t\u1eed nh\u01b0 BUFG, IBUFDS, BUFGCTL ..., clock b\u1ecb tr\u1ec5 \u0111i m\u1ed9t kho\u1ea3ng th\u1eddi gian Sau khi \u0111i qua c\u00e1c ph\u1ea7n t\u1eed t\u1ea1o clock nh\u01b0 MMCM2_ADV, PLL2_ADV..., t\u00f9y theo c\u1ea5u h\u00ecnh m\u00e0 clock c\u00f3 th\u1ec3 gi\u1ea3m ho\u1eb7c t\u0103ng \u0111\u1ed9 tr\u1ec5 (gi\u00e1 tr\u1ecb c\u00f3 th\u1ec3 \u00e2m ho\u1eb7c d\u01b0\u01a1ng). Ph\u1ea7n Data Path s\u1ebd m\u00f4 t\u1ea3 chi ti\u1ebft h\u01a1n v\u1ec1 delay gi\u1eefa F1/F2, c\u00e1i m\u00e0 \u0111\u00e3 \u0111\u01b0\u1ee3c nh\u1eafc \u0111\u1ebfn \u1edf m\u1ee5c Sumary. Ph\u1ea7n Destination Clock Path c\u00f3 ch\u1ee9c n\u0103ng t\u01b0\u01a1ng t\u1ef1 nh\u01b0 ph\u1ea7n Source Clock Path, s\u1ebd m\u00f4 t\u1ea3 chi ti\u1ebft \u0111\u01b0\u1eddng \u0111i c\u1ee7a Destination Clock Path. V\u1edbi Report nh\u01b0 tr\u00ean, ta c\u00f3 th\u1ec3 v\u1ebd \u0111\u01b0\u1ee3c Timing Diagram cho Path n\u00e0y nh\u01b0 sau: Trong \u0111\u00f3: Source Clock Path Delay b\u1eb1ng 0.975 ns \u0111\u01b0\u1ee3c t\u00ednh t\u1eeb t\u1ed5ng c\u00e1c delay tr\u00ean c\u00e1c ph\u1ea7n t\u1eed m\u00e0 clocks \u0111i qua, gi\u00e1 tr\u1ecb n\u00e0y c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c \u1edf d\u00f2ng cu\u1ed1i c\u00f9ng c\u1ee7a Source Clock Report. Data Path Delay b\u1eb1ng 0.424 ns l\u00e0 gi\u00e1 tr\u1ecb c\u1ee7a delay gi\u1eefa F1/F2, gi\u00e1 tr\u1ecb n\u00e0y c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c t\u1eeb d\u00f2ng cu\u1ed1i c\u00f9ng c\u1ee7a Data Path report. L\u01b0u \u00fd r\u1eb1ng gi\u00e1 tr\u1ecb \u0111\u1ecdc \u0111\u01b0\u1ee3c \u0111\u00e3 \u0111\u01b0\u1ee3c c\u1ed9ng th\u00eam Source Clock Path Delay. Destination Clock Path Delay b\u1eb1ng 1.559 ns \u0111\u01b0\u1ee3c t\u00ednh gi\u1ed1ng nh\u01b0 v\u1edbi Source Clock Path Delay. Gi\u00e1 tr\u1ecb Negative Hold Time Slack s\u1ebd \u0111\u01b0\u1ee3c t\u00ednh b\u1eb1ng: Source Clock Path Delay + Data Path Delay -- Destination Clock Path Delay = 0.975 ns + 0.424 ns -- 1.559 ns = - 0.220 ns** K\u1ebft qu\u1ea3 n\u00e0y gi\u1ed1ng v\u1edbi Report c\u1ee7a Xilinx Vivado. How does Vivado calculate Setup Time Slack? Qu\u00e1 tr\u00ecnh t\u00ednh to\u00e1n Setup Time Slack \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n t\u01b0\u01a1ng t\u1ef1 nh\u01b0 Hold Time Slack nh\u01b0 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n tr\u00ean hai s\u01b0\u1eddn clock kh\u00e1c nhau. Timing Analysis TCL Command get_clocks Description: \u0110\u01b0\u1ee3c d\u00f9ng \u0111\u1ec3 list ra c\u00e1c clocks trong thi\u1ebft k\u1ebf hi\u1ec7n t\u1ea1i. Syntax: get_clocks [-regexp] [-nocase] [-filter arg ] [-of_objects args ] [-match_style arg ] [-include_generated_clocks] [-quiet] verbose] [ patterns ] Examples: get_clocks //getting all clocks in current design get_clock adc* // getting all clocks that has pattern \"adc\" in its name get_clock {adc* clk_out1*} // getting all clocks that has any pattern listed in {} in its name get_clocks -include_generated_clocks adc_clk_fwd // getting adc_clk_fwd and all of its generated clocks report_clocks Description: reporting about a clocks or a list of clocks Syntax: report_clocks [-file arg ] [-append] [-return_string] [-quiet] [-verbose] [ clocks ] Examples: report_clocks // reporting all clocks in current design report_clocks --file report_clock_evt2a.txt // reporting and then outputting this content to an output file. Create output file if it is not existed. report_clocks [get_clocks adc_clk_fwd] // reporting about particular clock that is gotten by using get_clocks command.","title":"Vivado timing analysis report"},{"location":"fpga/timing_analysis/timing_analysis/#xilinx-design-constraint-xdc","text":"","title":"Xilinx Design Constraint (XDC)"},{"location":"fpga/timing_analysis/timing_analysis/#design-with-the-7-series","text":"Clocking Resources in 7 series. Clock regions: M\u1ed7i die FPGA \u0111\u01b0\u1ee3c chia th\u00e0nh c\u00e1c clock regions. Chi\u1ec1u cao (high) c\u1ee7a m\u1ed7i clock regions l\u00e0 50 CLBs (50 CLBs rows), b\u1ec1 r\u1ed9ng chi\u1ebfm m\u1ed9t n\u1eeda die. Clock Management Tile (CMT): M\u1ed7i clock region ch\u1ee9a m\u1ed9t CMT. Trong m\u1ed7i CMT ch\u1ee9a: 01 Mixed-Mode Clock Managers (MMCMs), 01 Phase Locked Loop (PLL). Clock-Capable Inputs (CCIO) : b\u1ea5t k\u00ec m\u1ed9t thi\u1ebft k\u1ebf FPGA \u0111\u1ed3ng b\u1ed9 n\u00e0o (synchronous design) \u0111\u1ec1u c\u1ea7n ph\u1ea3i cung c\u1ea5p \u00edt nh\u1ea5t m\u1ed9t \u0111\u01b0\u1eddng clock reference t\u1eeb b\u00ean ngo\u00e0i chip. \u0110\u01b0\u1eddng clock n\u00e0y s\u1ebd \u0111\u01b0\u1ee3c \u0111\u01b0a v\u00e0o chip FPGA b\u1eb1ng c\u00e1c port \u0111\u1eb7c bi\u1ec7t (clock-capable) \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf ri\u00eang cho clock. \u0110\u1ed1i v\u1edbi 7 series FPGA s\u1ebd c\u00f3 4 ports clock-capable. Trong \u0111\u00f3: 2 port l\u00e0 Multi-Region Clock Capable (MRCC), 2 ports c\u00f2n l\u1ea1i l\u00e0 Single Region Clock Capable (SRCC). IBUFG, IBUFGS c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 map t\u00edn hi\u1ec7u clock \u0111\u1ebfn c\u00e1c ch\u00e2n clock-capable. Global Clocking: Global clock networks cho pheps ph\u00e2n ph\u1ed1i clocks \u0111\u1ebfn c\u00e1c clocked element tr\u00ean chip die. Global clocks are driven by BUFGCTRL located in the middle of the die. Global Clocking Buffer (BUFGCTRL): For Clock Multiplexing - BUFGMUX For Gated Clock -- BUFGCE Horizontal Spine Clock Buffer (BUFH):","title":"Design with the 7 series"},{"location":"fpga/x_ipcore/xipcore/","text":"Xilinx IPCore This note for Xilinx Core implementation. Clocking Wizard Configure Clock Wizard using Dynamic Reconfiguration through AXI4-Lite interface. D\u00f2ng chip Series 7 c\u1ee7a Xilinx cung c\u1ea5p c\u00e1c t\u00e0i nguy\u00ean li\u00ean quan \u0111\u1ebfn clock nh\u01b0 MMCM v\u00e0 PLL (clock synthesizer). Ngo\u00e0i ra, trong m\u00f4i tr\u01b0\u1eddng Vivado, Xilinx cung c\u1ea5p th\u00eam IPCore Clocking Wizard nh\u1eb1m t\u1ea1o giao di\u1ec7n l\u00e0m vi\u1ec7c \u0111\u01a1n gi\u1ea3n cho ng\u01b0\u1eddi d\u00f9ng khi s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean clock tr\u00ean chip FPGA. Trong qu\u00e1 tr\u00ecnh ch\u1ea1y (run-time), c\u00e1c clock synthesizer c\u00f3 th\u1ec3 c\u1ea5u h\u00ecnh l\u1ea1i \u0111\u1ec3 c\u00f3 th\u1ec3 thay \u0111\u1ed5i \u0111\u01b0\u1ee3c gi\u00e1 tr\u1ecb t\u1ea7n s\u1ed1 \u0111\u1ea7u ra. Configuration Gi\u00e1 tr\u1ecb t\u1ea7n s\u1ed1 c\u1ee7a m\u1ed9t \u0111\u1ea7u ra c\u1ee7a kh\u1ed1i clock wizard \u0111\u01b0\u1ee3c t\u00ednh nh\u01b0 sau: VCO = CLKin * CLKFBOUT_MULT/DIVCLK_DIVICE CLKOUT0 = VCO / CLKOUT0_DIVIDE Trong qu\u00e1 tr\u00ecnh ch\u1ea1y, khi thay \u0111\u1ed5i c\u00e1c gi\u00e1 tr\u1ecb CLKFBOUT_MULT (Reg-offset: 0x200) ho\u1eb7c gi\u00e1 tr\u1ecb CLOCKOUT0_DEVICE (Reg-offset: 0x208) th\u00ec gi\u00e1 tr\u1ecb CLKOUT0 s\u1ebd thay \u0111\u1ed5i. Tham kh\u1ea3o th\u00eam Register Space trong t\u00e0i li\u1ec7u PG065. Quy tr\u00ecnh c\u1ea5u h\u00ecnh lai clock Trong PG065 m\u00f4 t\u1ea3 quy tr\u00ecnh c\u1ea5u h\u00ecnh l\u1ea1i clock t\u1ea1i \"Dynamic Reconfiguration through AXI4-Lite\" L\u01b0u \u00fd qu\u00e1 tr\u00ecnh c\u1ea5u h\u00ecnh: Nh\u1eadp m\u1edbi gi\u00e1 tr\u1ecb thanh ghi Ghi gi\u00e1 tr\u1ecb 0x7 v\u00e0o thanh ghi 0x25c Ghi gi\u00e1 tr\u1ecb 0x3 v\u00e0o thanh ghi 0x25c This configuration sequence is referenced from Clocking Wizard example design. References","title":"Xilinx IPCore"},{"location":"fpga/x_ipcore/xipcore/#xilinx-ipcore","text":"This note for Xilinx Core implementation.","title":"Xilinx IPCore"},{"location":"fpga/x_ipcore/xipcore/#clocking-wizard","text":"Configure Clock Wizard using Dynamic Reconfiguration through AXI4-Lite interface. D\u00f2ng chip Series 7 c\u1ee7a Xilinx cung c\u1ea5p c\u00e1c t\u00e0i nguy\u00ean li\u00ean quan \u0111\u1ebfn clock nh\u01b0 MMCM v\u00e0 PLL (clock synthesizer). Ngo\u00e0i ra, trong m\u00f4i tr\u01b0\u1eddng Vivado, Xilinx cung c\u1ea5p th\u00eam IPCore Clocking Wizard nh\u1eb1m t\u1ea1o giao di\u1ec7n l\u00e0m vi\u1ec7c \u0111\u01a1n gi\u1ea3n cho ng\u01b0\u1eddi d\u00f9ng khi s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean clock tr\u00ean chip FPGA. Trong qu\u00e1 tr\u00ecnh ch\u1ea1y (run-time), c\u00e1c clock synthesizer c\u00f3 th\u1ec3 c\u1ea5u h\u00ecnh l\u1ea1i \u0111\u1ec3 c\u00f3 th\u1ec3 thay \u0111\u1ed5i \u0111\u01b0\u1ee3c gi\u00e1 tr\u1ecb t\u1ea7n s\u1ed1 \u0111\u1ea7u ra. Configuration Gi\u00e1 tr\u1ecb t\u1ea7n s\u1ed1 c\u1ee7a m\u1ed9t \u0111\u1ea7u ra c\u1ee7a kh\u1ed1i clock wizard \u0111\u01b0\u1ee3c t\u00ednh nh\u01b0 sau: VCO = CLKin * CLKFBOUT_MULT/DIVCLK_DIVICE CLKOUT0 = VCO / CLKOUT0_DIVIDE Trong qu\u00e1 tr\u00ecnh ch\u1ea1y, khi thay \u0111\u1ed5i c\u00e1c gi\u00e1 tr\u1ecb CLKFBOUT_MULT (Reg-offset: 0x200) ho\u1eb7c gi\u00e1 tr\u1ecb CLOCKOUT0_DEVICE (Reg-offset: 0x208) th\u00ec gi\u00e1 tr\u1ecb CLKOUT0 s\u1ebd thay \u0111\u1ed5i. Tham kh\u1ea3o th\u00eam Register Space trong t\u00e0i li\u1ec7u PG065. Quy tr\u00ecnh c\u1ea5u h\u00ecnh lai clock Trong PG065 m\u00f4 t\u1ea3 quy tr\u00ecnh c\u1ea5u h\u00ecnh l\u1ea1i clock t\u1ea1i \"Dynamic Reconfiguration through AXI4-Lite\" L\u01b0u \u00fd qu\u00e1 tr\u00ecnh c\u1ea5u h\u00ecnh: Nh\u1eadp m\u1edbi gi\u00e1 tr\u1ecb thanh ghi Ghi gi\u00e1 tr\u1ecb 0x7 v\u00e0o thanh ghi 0x25c Ghi gi\u00e1 tr\u1ecb 0x3 v\u00e0o thanh ghi 0x25c This configuration sequence is referenced from Clocking Wizard example design. References","title":"Clocking Wizard"},{"location":"ldd/kernel_module/","text":"About Kernel Module Kernel Module Information Print log in Kernel module About dynamic debug: https://www.kernel.org/doc/html/v4.15/admin-guide/dynamic-debug-howto.html printk() function printk's usage is familiar with printf() in c programing. dev_* functions pr_* functions","title":"Kernel Module"},{"location":"ldd/kernel_module/#about-kernel-module","text":"","title":"About Kernel Module"},{"location":"ldd/kernel_module/#kernel-module-information","text":"","title":"Kernel Module Information"},{"location":"ldd/kernel_module/#print-log-in-kernel-module","text":"About dynamic debug: https://www.kernel.org/doc/html/v4.15/admin-guide/dynamic-debug-howto.html printk() function printk's usage is familiar with printf() in c programing. dev_* functions pr_* functions","title":"Print log in Kernel module"},{"location":"ldd/overview/","text":"Overview about Linux Device Driver T\u00e0i li\u1ec7u n\u00e0y m\u00f4 t\u1ea3 c\u00e1c kh\u00e1i ni\u1ec7m chung v\u1ec1 Linux Device Driver. C\u1ea7n c\u00f3 c\u00e1c b\u00e0i t\u00ecm hi\u1ec3u chuy\u00ean s\u00e2u v\u1ec1 c\u00e1c m\u1ee5c trong ph\u1ea7n n\u00e0y. Original note Linux System Overview Linux Device Model C\u00e1c thi\u1ebft b\u1ecb k\u1ebft n\u1ed1i \u0111\u1ebfn CPU \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 Device . M\u1ed7i device n\u00e0y cung c\u1ea5p c\u00e1c t\u00e0i nguy\u00ean kh\u00e1c nhau \u0111\u1ebfn ng\u01b0\u1eddi d\u00f9ng, Linux kernel th\u00f4ng qua device driver \u0111\u1ec3 giao ti\u1ebfp \u0111\u1ebfn device v\u00e0 s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean c\u1ee7a device \u0111\u00f3. C\u00e1c device k\u1ebft n\u1ed1i \u0111\u1ebfn CPU b\u1eb1ng m\u1ed9t bus. N\u00f3 c\u00f3 th\u1ec3 l\u00e0 c\u00e1c bus giao ti\u1ebfp v\u1edbi thi\u1ebft b\u1ecb ngo\u1ea1i vi nh\u01b0 SPI, I2C, ho\u1eb7c c\u0169ng c\u00f3 th\u1ec3 l\u00e0 system bus c\u1ee7a h\u1ec7 th\u1ed1ng. L\u01b0u \u00fd r\u1eb1ng Linux Kernel c\u0169ng nh\u00ecn bus gi\u1ed1ng nh\u01b0 m\u1ed9t device v\u00e0 t\u1ea5t nhi\u00ean device th\u00ec c\u1ea7n ph\u1ea3i \u0111\u01b0\u1ee3c khai b\u00e1o. Do \u0111\u00f3 Linux Kernel c\u0169ng cung c\u1ea5p c\u00e1c quy tr\u00ecnh \u0111\u1ec3 \u0111\u0103ng k\u00fd m\u1ed9t bus v\u1edbi h\u1ec7 th\u1ed1ng. Trong qu\u00e1 tr\u00ecnh kh\u1edfi \u0111\u1ed9ng, d\u1ef1a v\u00e0o th\u00f4ng tin m\u00e0 device-tree cung c\u1ea5p v\u1ec1 c\u00e1c device trong h\u1ec7 th\u1ed1ng, Linux Kernel g\u1ecdi \u0111\u1ebfn c\u00e1c device driver t\u01b0\u01a1ng \u1ee9ng \u0111\u1ec3 d\u00f2 t\u00ecm v\u00e0 th\u00eam thi\u1ebft b\u1ecb v\u00e0o h\u1ec7 th\u1ed1ng. Platform device l\u00e0 c\u00e1c device \u0111\u1ea7u ti\u00ean \u0111\u01b0\u1ee3c d\u00f2 t\u00ecm v\u00e0 th\u00eam v\u00e0o h\u1ec7 th\u1ed1ng. \u0110\u01a1n gi\u1ea3n c\u00f3 th\u1ec3 hi\u1ec3u c\u00e1c platform device l\u00e0 c\u00e1c thi\u1ebft b\u1ecb \u0111\u01b0\u1ee3c qu\u1ea3n l\u00fd tr\u1ef1c ti\u1ebfp trong v\u00f9ng nh\u1edb c\u1ee7a CPU, l\u00e0 c\u00e1c th\u1ef1c th\u1ec3 \u0111\u01b0\u1ee3c n\u1ed1i v\u1edbi system bus c\u1ee7a CPU. System bus n\u00e0y \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 platform bus. Figure. An example about device model Kernel Module \u0110\u1ecbnh ngh\u0129a Kernel Module l\u00e0 m\u1ed9t \u0111o\u1ea1n m\u00e3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t ho\u1eb7c g\u1ee1 c\u00e0i \u0111\u1eb7t kh\u1ecfi Kernel theo y\u00eau c\u1ea7u. Kernel module gi\u00fap m\u1edf r\u1ed9ng ch\u1ee9c n\u0103ng cho kernel m\u00e0 kh\u00f4ng c\u1ea7n ph\u1ea3i kh\u1edfi \u0111\u1ed9ng l\u1ea1i h\u1ec7 th\u1ed1ng. Device Driver l\u00e0 m\u1ed9t lo\u1ea1i kernel module. Trong tr\u01b0\u1eddng h\u1ee3p c\u1ea7n th\u00eam m\u1ed9t ch\u1ee9c n\u0103ng v\u00e0o kernel trong khi kh\u00f4ng c\u00f3 kernel module, ng\u01b0\u1eddi ph\u00e1t tri\u1ec3n s\u1ebd c\u1ea7n ph\u1ea3i build l\u1ea1i c\u1ea3 h\u1ec7 th\u1ed1ng. M\u1ed9t blog vi\u1ebft v\u1ec1 Kernel Module t\u01b0\u01a1ng \u0111\u1ed1i hay v\u00e0 chi ti\u1ebft c\u00f3 th\u1ec3 xem th\u00eam t\u1ea1i \u0111\u00e2y . Blog \u0111\u01b0\u1ee3c vi\u1ebft b\u1edfi Derek Molloy. Kernel Module c\u0169ng \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a t\u1ea1i m\u1ed9t b\u00e0i vi\u1ebft c\u1ee7a ArchLinux (m\u1ed9t Linux Distro) t\u1ea1i \u0111\u00e2y . Ngo\u00e0i ra, tai trang web tldp.org c\u00f3 m\u1ed9t chu\u1ed7i c\u00e1c b\u00e0i vi\u1ebft li\u00ean quan \u0111\u1ebfn ph\u00e1t tri\u1ec3n Kernel module ( The Linux Kernel Module Programming Guide ). C\u00f3 hai d\u1ea1ng Kernel module: build-in v\u00e0 loadable file. Trong \u0111\u00f3 built-in module \u0111\u01b0\u1ee3c t\u00edch h\u1ee3p v\u00e0o Kernel Image v\u00e0 \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng trong qu\u00e1 tr\u00ecnh kh\u1edfi \u0111\u1ed9ng kernel. Ng\u01b0\u1eddi l\u1ea1i, loadable module c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c ng\u01b0\u1eddi d\u00f9ng c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng sau khi kernel \u0111\u00e3 kh\u1edfi \u0111\u1ed9ng th\u00e0nh c\u00f4ng. Loadable Kernel Module (LKM) \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng b\u1eb1ng c\u00e1c c\u00e2u l\u1ec7nh nh\u01b0 modprobe ho\u1eb7c insmod. module_init module_exit Kernel module c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c hi\u1ec3u l\u00e0 m\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh ch\u1ea1y trong Kernel Space, nh\u01b0ng kh\u00f4ng gi\u1ed1ng nh\u01b0 ch\u01b0\u01a1ng tr\u00ecnh b\u00ecnh th\u01b0\u1eddng, kernel module kh\u00f4ng b\u1eaft \u0111\u1ea7u b\u1eb1ng h\u00e0m \"main\". Macro module_init() v\u00e0 module_exit() \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u0103ng k\u00fd c\u00e1c h\u00e0m kh\u1edfi t\u1ea1o v\u00e0 h\u00e0m h\u1ee7y cho kernel module. T\u00f9y thu\u1ed9c v\u00e0o kernel module l\u00e0 built-in hay LKM m\u00e0 n\u1ed9i d\u1ee5ng c\u1ee7a module_init/exit s\u1ebd kh\u00e1c nhau. Trong tr\u01b0\u1eddng h\u1ee3p l\u00e0 built-in module, module_init s\u1ebd g\u1ecdi \u0111\u1ebfn macro _init_call d\u00f9ng \u0111\u1ec3 \u0111\u0103ng k\u00fd v\u1edbi h\u1ec7 th\u1ed1ng l\u00e0 module s\u1ebd \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o tr\u1ecdng qu\u00e1 tr\u00ecnh init. Hai macro \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong linux/init.h. In log trong kernel Ph\u01b0\u01a1ng ph\u00e1p debug c\u01a1 b\u1ea3n v\u00e0 ph\u1ed5 bi\u1ebfn nh\u1ea5t khi \u0111i ph\u00e1t tri\u1ec3n m\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh l\u00e0 in log ch\u1ea1y c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh \u0111\u00f3 ra m\u00e0n h\u00ecnh ho\u1eb7c file. Kernel module s\u1eed d\u1ee5ng l\u1ec7nh prink thay v\u00ec printf nh\u01b0 ph\u00e1t tri\u1ec3n \u1ee9ng d\u1ee5ng User space. Ngo\u00e0i ra c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng th\u00eam c\u00e1c h\u1ecd h\u00e0m dev_ v\u00e0 pr_ \u0111\u1ec3 in th\u00eam th\u00f4ng tin trong kernel module. C\u00e0i \u0111\u1eb7t LKM module v\u00e0o h\u1ec7 th\u1ed1ng \u0110\u1ec3 c\u00e0i \u0111\u1eb7t LKM v\u00e0o h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng l\u1ec7nh insmod/rmmod/lsmod . Ngo\u00e0i ra c\u00f3 th\u1ec3 d\u00f9ng th\u00eam modprobe. Qu\u00e1 tr\u00ecnh s\u1eed d\u1ee5ng modprobe ph\u1ee9c t\u1ea1p h\u01a1n insmod, c\u00f3 th\u1ec3 \u0111\u1ecdc th\u00eam [t\u1ea1i \u0111\u00e2y] . Trong qu\u00e1 tr\u00ecnh c\u00e0i \u0111\u1eb7t module v\u00e0o h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 th\u00eam c\u00e1c paramtters cho module. \u0110\u1ec3 li\u1ec7t k\u00ea to\u00e0n b\u1ed9 th\u00f4ng tin c\u1ee7a c\u00e1c module \u0111ang \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t trong h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng lsmod. Lsmod \u0111\u1ecdc th\u00f4ng tin t\u1eeb /proc/modules, ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 \u0111\u1ecdc tr\u1ef1c ti\u1ebfp t\u1eeb text file /proc/modules \u0111\u1ec3 bi\u1ebft th\u00eam \u0111\u01b0\u1ee3c th\u00f4ng tin c\u1ee7a c\u00e1c module \u0111ang ch\u1ea1y trong h\u1ec7 th\u1ed1ng. Khi m\u1ed9t module \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng, th\u00f4ng tin v\u1ec1 module n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y trong sysfs virtual file system /sys/module Compile a kernel module \u0110\u1ec3 build m\u1ed9t kernel module, Linux Kernel s\u1eed d\u1ee5ng m\u1ed9t h\u1ec7 th\u1ed1ng g\u1ecdi l\u00e0 kbuild. C\u00f3 th\u1ec3 \u0111\u1ecdc th\u00eam th\u00f4ng tin v\u1ec1 h\u1ec7 th\u1ed1ng kbuild n\u00e0y trong Kernel Documentation ( kbuild/modules.txt ). Trong m\u1ee5c 2.2 c\u1ee7a [1] c\u00f3 gi\u1edbi thi\u1ec7u v\u1ec1 build kernel module. Character Device Driver Device Driver l\u00e0 m\u1ed9t kernel module, c\u00f3 ch\u1ee9c n\u0103ng giao ti\u1ebfp tr\u1ef1c ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng v\u00e0 cung c\u1ea5p c\u00e1c giao di\u1ec7n \u0111\u1ec3 c\u00e1c module kh\u00e1c c\u1ee7a kernel c\u0169ng nh\u01b0 user c\u00f3 th\u1ec3 truy c\u1eadp v\u00e0 s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean li\u00ean quan \u0111\u1ebfn c\u00e1c ph\u1ea7n c\u1ee9ng t\u01b0\u01a1ng \u1ee9ng. T\u00f9y thu\u1ed9c v\u00e0o lo\u1ea1i ph\u1ea7n c\u1ee9ng t\u01b0\u01a1ng \u1ee9ng m\u00e0 device driver \u0111\u01b0\u1ee3c chia ra l\u00e0m c\u00e1c lo\u1ea1i kh\u00e1c nhau. Trong t\u00e0i li\u1ec7u LDD3, device driver \u0111\u01b0\u1ee3c chia ra l\u00e0m 3 lo\u1ea1i ch\u00ednh: char module, block module v\u00e0 network module. Trong \u0111\u00f3 character device s\u1ebd \u0111\u01b0\u1ee3c t\u1eadp trung nghi\u00ean c\u1ee9u trong t\u00e0i li\u1ec7u n\u00e0y. Nh\u01b0 v\u1eady, m\u1ed9t device driver n\u00f3i chung c\u1ea7n th\u1ef1c hi\u1ec7n hai nhi\u1ec7m v\u1ee5 ch\u00ednh: Cung c\u1ea5p c\u00e1c giao di\u1ec7n \u0111\u1ec3 c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi User Space, qua \u0111\u00f3 c\u00e1c \u1ee9ng d\u1ee5ng c\u1ee7a ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi ph\u1ea7n c\u1ee9ng th\u00f4ng qua c\u00e1c giao di\u1ec7n n\u00e0y. Truy c\u1eadp \u0111\u1ebfn ph\u1ea7n c\u1ee9ng. Device driver \u0111\u01b0\u1ee3c sinh ra l\u00e0 \u0111\u1ec3 giao ti\u1ebfp tr\u1ef1c ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng. Trong t\u00e0i li\u1ec7u n\u00e0y s\u1ebd t\u00ecm hi\u1ec3u t\u1eebng nhi\u1ec7m v\u1ee5 tr\u00ean c\u1ee7a Device Driver. Device File Device file hay special file l\u00e0 m\u1ed9t giao di\u1ec7n \u0111\u1ec3 ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi device driver. Th\u00f4ng th\u01b0\u1eddng c\u00e1c device file xu\u1ea5t hi\u1ec7n trong /dev/ v\u00e0 \u0111\u01b0\u1ee3c qu\u1ea3n l\u00fd b\u1edfi virtual file system. Ng\u01b0\u1eddi d\u00f9ng th\u00f4ng qua c\u00e1c System Call \u0111\u1ec3 t\u01b0\u01a1ng t\u00e1c v\u1edbi device driver th\u00f4ng qua device file. C\u00e1c System Call li\u00ean quan \u0111\u1ebfn t\u01b0\u01a1ng t\u00e1c file \u0111\u01b0\u1ee3c x\u1eed l\u00fd b\u1edfi h\u1ec7 th\u1ed1ng VFS (Virtual File System) nh\u01b0: open(), close(), read(), write(), mmpa()... Qu\u00e1 tr\u00ecnh ho\u1ea1t \u0111\u1ed9ng c\u1ee7a c\u00e1c system call n\u00e0y \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 r\u00f5 trong Chapter 12: The Virtual File System c\u1ee7a s\u00e1ch Understanding Linux Kernel. V\u1eady v\u1edbi m\u1ed9t normal file, c\u00e1c ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 t\u00e1c \u0111\u1ed9ng g\u00ec \u0111\u01b0\u1ee3c? Th\u00f4ng tin n\u00e0y c\u00f3 th\u1ec3 t\u00ecm hi\u1ec3u qua t\u1eeb kh\u00f3a \"Working with file in C\". Major Minor M\u1ed7i Device File trong /dev/ \u0111\u01b0\u1ee3c \u0111\u1eb7c tr\u01b0ng b\u1edfi hai tham s\u1ed1: Major, Minor . Major \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 x\u00e1c \u0111\u1ecbnh xem device \u0111\u00f3 t\u01b0\u01a1ng \u1ee9ng v\u1edbi driver n\u00e0o. Minor mang th\u00f4ng tin c\u1ee7a t\u1eebng thi\u1ebft b\u1ecb, v\u1ec1 c\u01a1 b\u1ea3n nhi\u1ec1u thi\u1ebft b\u1ecb c\u00f3 th\u1ec3 \u0111i\u1ec1u khi\u1ec3n b\u1eb1ng m\u1ed9t driver, do \u0111\u00f3 trong m\u1ed9t s\u1ed1 h\u1ec7 th\u1ed1ng, driver s\u1eed d\u1ee5ng Minor \u0111\u1ec3 ph\u00e2n bi\u1ec7t gi\u1eefa c\u00e1c thi\u1ebft b\u1ecb v\u1edbi nhau. Major v\u00e0 Minor t\u1ea1o th\u00e0nh m\u1ed9t c\u1eb7p s\u1ed1 unsigned \u0111\u1ec3 \u0111\u1eb7c tr\u01b0ng cho m\u1ed9t device, g\u1ecdi l\u00e0 Device Number. Kernel s\u1eed d\u1ee5ng ki\u1ec3u d\u1eef li\u1ec7u dev_t \u0111\u1ec3 m\u00f4 t\u1ea3 hai tham s\u1ed1 n\u00e0y. Dev_t \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong header linux/types d\u01b0\u1edbi d\u1ea1ng m\u1ed9t s\u1ed1 32 bit. typedef __u32 __kernel_dev_t; typedef __kernel_dev_t dev_t; Trong \u0111\u00f3, 20 bit th\u1ea5p \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho Minor v\u00e0 c\u00e1c bit cao c\u00f2n l\u1ea1i \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho Major. C\u00e1c macro s\u1eed d\u1ee5ng cho dev_t nh\u01b0 MKDEV, MAJOR, MINOR \u0111\u01b0\u1ee3c khai b\u00e1o trong linux/k_dev_t.h . C\u00f3 th\u1ec3 t\u1ea1o m\u1ed9t Device File \u0111\u01a1n gi\u1ea3n b\u1eb1ng Command: mknod /dev/coffee c 12 2 . Khai b\u00e1o m\u1ed9t Character Device File C\u1ea5p ph\u00e1t Device Number H\u00e0m register_chrdev_region() \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u0103ng k\u00fd device number. int register_chrdev_region(dev_t from, unsigned count, const char *name); Qu\u00e1 tr\u00ecnh n\u00e0y l\u00e0 c\u1ea5p ph\u00e1t t\u0129nh dev_t, trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p y\u00eau c\u1ea7u c\u1ea5p ph\u00e1t n\u00e0y kh\u00f4ng th\u00e0nh c\u00f4ng do y\u00eau c\u1ea7u c\u1ee7a driver kh\u00f4ng ph\u00f9 h\u1ee3p v\u1edbi y\u00eau c\u1ea7u hi\u1ec7n t\u1ea1i c\u1ee7a h\u1ec7 th\u1ed1ng. Trong tr\u01b0\u1eddng h\u1ee3p \u0111\u00f3 c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng h\u00e0m alloc_chrdev_region() . Nguy\u00ean m\u1eabu c\u1ee7a h\u00e0m \u0111\u00f3 nh\u01b0 sau: int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,*const char *name); K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh c\u1ea5p ph\u00e1t device number l\u00e0 Major v\u00e0 m\u1ed9t d\u1ea3i Minor m\u00e0 driver c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng. \u0110\u0103ng k\u00fd Character Device File Kernel s\u1eed d\u1ee5ng m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1ec3 l\u01b0u gi\u1eef th\u00f4ng tin c\u1ee7a m\u1ed9t character device: struct cdev. Struct cdev \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong linux/cdev.h bao g\u1ed3m c\u00e1c tr\u01b0\u1eddng th\u00f4ng tin \u1edf b\u1ea3ng sau. structcdev{ struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; unsigned int count; } __randomize_layout; M\u1ed7i char device t\u01b0\u01a1ng \u1ee9ng v\u1edbi m\u1ed9t device number dev_t v\u00e0 c\u00f3 c\u00e1c file_operations t\u01b0\u1edbng \u1ee9ng. C\u00e1c file_operations (\u0111\u1ecbnh ngh\u0129a trong linux/fs.h ) \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 trong b\u1ea3ng sau. struct file_operations { ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); int (*mmap) (struct file *, struct vm_area_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); [some feilds obmitted] } __randomize_layout; cdev_init cdev_add Tr\u01b0\u1edbc khi kh\u1edfi t\u1ea1o v\u00e0 \u0111\u0103ng k\u00fd m\u1ed9t cdev v\u1edbi kernel, m\u1ed9t v\u00f9ng nh\u1edb s\u1eed d\u1ee5ng cho bi\u1ebfn cdev n\u00e0y ph\u1ea3i \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o. Ph\u01b0\u01a1ng ph\u00e1p \u0111\u01a1n gi\u1ea3n nh\u1ea5t l\u00e0 khai b\u00e1o m\u1ed9t bi\u1ebfn to\u00e0n c\u1ee5c trong driver. Qu\u00e1 tr\u00ecnh cdev_init b\u1ea3n ch\u1ea5t l\u00e0 trang b\u1ecb file_openratons cho cdev v\u00e0 th\u00eam n\u00f3 v\u00e0o danh s\u00e1ch c\u00e1c thi\u1ebft b\u1ecb \u0111\u00e3 \u0111\u01b0\u1ee3c khai b\u00e1o trong h\u1ec7 th\u1ed1ng. H\u00e0m cdev_add ti\u1ebfn h\u00e0nh th\u00eam cdev v\u00e0o h\u1ec7 th\u1ed1ng. L\u01b0u \u00fd nguy\u00ean m\u1eabu h\u00e0m cdev_add nh\u01b0 sau: int cdev_add(struct cdev *p, dev_t dev, unsigned count); Trong \u0111\u00f3 con tr\u1ecf p \u0111\u01b0\u1ee3c tr\u1ecf \u0111\u1ebfn bi\u1ebfn cdev \u0111\u00e3 \u0111\u01b0\u1ee3c khai b\u00e1o, v\u00e0 dev_t dev l\u00e0 device number \u0111\u1ea7u ti\u00ean trong d\u00e3y c\u00e1c device number li\u00ean quan \u0111\u1ebfn cdev n\u00e0y, count l\u00e0 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c minor number li\u00ean ti\u1ebfp sau MINOR(dev_t dev) li\u00ean quan \u0111\u1ebfn device n\u00e0y. Gi\u1ea3 s\u1eed ta ti\u1ebfn h\u00e0nh th\u00eam m\u1ed9t cdev nh\u01b0 sau: struct cdev mycdev; dev_t mydevno = MKDEV(246, 0); cdev_add(mycdev, mydevno, 4); V\u00e0 sau \u0111\u00f3 kh\u1edfi t\u1ea1o th\u00eam 4 files. mknod /dev/scull0 c 246 0 mknod /dev/scull1 c 246 1 mknod /dev/scull2 c 246 2 mknod /dev/scull3 c 246 3 Khi ti\u1ebfn h\u00e0nh \u0111\u1ecdc ghi c\u00e1c /dev/file n\u00e0y \u0111\u1ec3u tr\u1ea3 v\u1ec1 m\u1ed9t dev_t duy nh\u1ea5t 246, 0 . Mutex http://derekmolloy.ie/writing-a-linux-kernel-module-part-2-a-character-device/ MMAP https://nhauyeneducation.blogspot.com/2018/11/hieu-ve-to-chuc-bo-nho-linux-thong-qua.html?fbclid=IwAR2w4W3yttmtqbZYqcwzTQ95Qvs92ZXDdBXns9kgO7IeokpVvoc8OY3IVLo https://linux-kernel-labs.github.io/master/labs/memory_mapping.html IOCTL https://ufal.mff.cuni.cz/~jernej/2018/docs/predavanja06.pdf Ioctl - Input Output Control \u0111\u01b0\u1ee3c sinh ra \u0111\u1ec3 h\u1ed7 tr\u1ee3 ng\u01b0\u1eddi d\u00f9ng khai b\u00e1o th\u00eam c\u00e1c c\u00e2u l\u1ec7nh m\u1edbi ph\u00f9 h\u1ee3p v\u1edbi t\u1eebng d\u00f2ng thi\u1ebft b\u1ecb. Trong v\u00ed d\u1ee5 li\u00ean quan \u0111\u1ebfn b\u00e0i \u0111\u00e0o t\u1ea1o, led_controller_core c\u00f3 hai tham s\u1ed1 c\u00f3 th\u1ec3 c\u1ea5u h\u00ecnh \u0111\u01b0\u1ee3c trong qu\u00e1 tr\u00ecnh ch\u1ea1y: SPEED: T\u1ed1c \u0111\u1ed9 LED. POSITION: V\u1ecb tr\u00ed LED nh\u00e1y. - M\u1ee5c ti\u00eau c\u1ea7n ph\u1ea3i \u0111\u1ecbnh ngh\u0129a \u0111\u01b0\u1ee3c m\u1ed9t s\u1ed1 c\u00e2u l\u1ec7nh \u0111\u1ec3 l\u00e0m v\u00ed d\u1ee5 trong qu\u00e1 tr\u00ecnh ph\u00e1t tri\u1ec3n. Giao ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng Platform Device Giao ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng trong m\u1ed9t h\u1ec7 nh\u00fang r\u1ea5t \u0111a d\u1ea1ng. Ph\u01b0\u01a1ng ph\u00e1p giao ti\u1ebfp v\u1edbi ph\u1ea7n t\u1eed trong h\u1ec7 nh\u00fang ph\u1ee5 thu\u1ed9c v\u00e0o lo\u1ea1i thi\u1ebft b\u1ecb c\u1ee7a ph\u1ea7n t\u1eed \u0111\u00f3. Trong ph\u1ea1m vi b\u00e0i vi\u1ebft n\u00e0y s\u1ebd t\u01b0\u01a1ng t\u00e1c v\u1edbi m\u1ed9t lo\u1ea1i thi\u1ebft b\u1ecb: platform_device. struct resource platform_get_resource th\u1ef1c hi\u1ec7n t\u00ecm ki\u1ebfm t\u1ea5t c\u1ea3 c\u00e1c resource hi\u1ec7n t\u1ea1i c\u00f3 trong platform_device. Qu\u00e1 tr\u00ecnh t\u00ecm ki\u1ebfm d\u1ef1a v\u00e0o lo\u1ea1i resource \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong linux/ioport.h. C\u00e1c lo\u1ea1i resource c\u01a1 b\u1ea3n nh\u01b0: IORESOURCE_MEM (memory) IORESOURCE_IRQ (interupt)","title":"Overview"},{"location":"ldd/overview/#overview-about-linux-device-driver","text":"T\u00e0i li\u1ec7u n\u00e0y m\u00f4 t\u1ea3 c\u00e1c kh\u00e1i ni\u1ec7m chung v\u1ec1 Linux Device Driver. C\u1ea7n c\u00f3 c\u00e1c b\u00e0i t\u00ecm hi\u1ec3u chuy\u00ean s\u00e2u v\u1ec1 c\u00e1c m\u1ee5c trong ph\u1ea7n n\u00e0y. Original note","title":"Overview about Linux Device Driver"},{"location":"ldd/overview/#linux-system-overview","text":"","title":"Linux System Overview"},{"location":"ldd/overview/#linux-device-model","text":"C\u00e1c thi\u1ebft b\u1ecb k\u1ebft n\u1ed1i \u0111\u1ebfn CPU \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 Device . M\u1ed7i device n\u00e0y cung c\u1ea5p c\u00e1c t\u00e0i nguy\u00ean kh\u00e1c nhau \u0111\u1ebfn ng\u01b0\u1eddi d\u00f9ng, Linux kernel th\u00f4ng qua device driver \u0111\u1ec3 giao ti\u1ebfp \u0111\u1ebfn device v\u00e0 s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean c\u1ee7a device \u0111\u00f3. C\u00e1c device k\u1ebft n\u1ed1i \u0111\u1ebfn CPU b\u1eb1ng m\u1ed9t bus. N\u00f3 c\u00f3 th\u1ec3 l\u00e0 c\u00e1c bus giao ti\u1ebfp v\u1edbi thi\u1ebft b\u1ecb ngo\u1ea1i vi nh\u01b0 SPI, I2C, ho\u1eb7c c\u0169ng c\u00f3 th\u1ec3 l\u00e0 system bus c\u1ee7a h\u1ec7 th\u1ed1ng. L\u01b0u \u00fd r\u1eb1ng Linux Kernel c\u0169ng nh\u00ecn bus gi\u1ed1ng nh\u01b0 m\u1ed9t device v\u00e0 t\u1ea5t nhi\u00ean device th\u00ec c\u1ea7n ph\u1ea3i \u0111\u01b0\u1ee3c khai b\u00e1o. Do \u0111\u00f3 Linux Kernel c\u0169ng cung c\u1ea5p c\u00e1c quy tr\u00ecnh \u0111\u1ec3 \u0111\u0103ng k\u00fd m\u1ed9t bus v\u1edbi h\u1ec7 th\u1ed1ng. Trong qu\u00e1 tr\u00ecnh kh\u1edfi \u0111\u1ed9ng, d\u1ef1a v\u00e0o th\u00f4ng tin m\u00e0 device-tree cung c\u1ea5p v\u1ec1 c\u00e1c device trong h\u1ec7 th\u1ed1ng, Linux Kernel g\u1ecdi \u0111\u1ebfn c\u00e1c device driver t\u01b0\u01a1ng \u1ee9ng \u0111\u1ec3 d\u00f2 t\u00ecm v\u00e0 th\u00eam thi\u1ebft b\u1ecb v\u00e0o h\u1ec7 th\u1ed1ng. Platform device l\u00e0 c\u00e1c device \u0111\u1ea7u ti\u00ean \u0111\u01b0\u1ee3c d\u00f2 t\u00ecm v\u00e0 th\u00eam v\u00e0o h\u1ec7 th\u1ed1ng. \u0110\u01a1n gi\u1ea3n c\u00f3 th\u1ec3 hi\u1ec3u c\u00e1c platform device l\u00e0 c\u00e1c thi\u1ebft b\u1ecb \u0111\u01b0\u1ee3c qu\u1ea3n l\u00fd tr\u1ef1c ti\u1ebfp trong v\u00f9ng nh\u1edb c\u1ee7a CPU, l\u00e0 c\u00e1c th\u1ef1c th\u1ec3 \u0111\u01b0\u1ee3c n\u1ed1i v\u1edbi system bus c\u1ee7a CPU. System bus n\u00e0y \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 platform bus. Figure. An example about device model","title":"Linux Device Model"},{"location":"ldd/overview/#kernel-module","text":"","title":"Kernel Module"},{"location":"ldd/overview/#inh-nghia","text":"Kernel Module l\u00e0 m\u1ed9t \u0111o\u1ea1n m\u00e3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t ho\u1eb7c g\u1ee1 c\u00e0i \u0111\u1eb7t kh\u1ecfi Kernel theo y\u00eau c\u1ea7u. Kernel module gi\u00fap m\u1edf r\u1ed9ng ch\u1ee9c n\u0103ng cho kernel m\u00e0 kh\u00f4ng c\u1ea7n ph\u1ea3i kh\u1edfi \u0111\u1ed9ng l\u1ea1i h\u1ec7 th\u1ed1ng. Device Driver l\u00e0 m\u1ed9t lo\u1ea1i kernel module. Trong tr\u01b0\u1eddng h\u1ee3p c\u1ea7n th\u00eam m\u1ed9t ch\u1ee9c n\u0103ng v\u00e0o kernel trong khi kh\u00f4ng c\u00f3 kernel module, ng\u01b0\u1eddi ph\u00e1t tri\u1ec3n s\u1ebd c\u1ea7n ph\u1ea3i build l\u1ea1i c\u1ea3 h\u1ec7 th\u1ed1ng. M\u1ed9t blog vi\u1ebft v\u1ec1 Kernel Module t\u01b0\u01a1ng \u0111\u1ed1i hay v\u00e0 chi ti\u1ebft c\u00f3 th\u1ec3 xem th\u00eam t\u1ea1i \u0111\u00e2y . Blog \u0111\u01b0\u1ee3c vi\u1ebft b\u1edfi Derek Molloy. Kernel Module c\u0169ng \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a t\u1ea1i m\u1ed9t b\u00e0i vi\u1ebft c\u1ee7a ArchLinux (m\u1ed9t Linux Distro) t\u1ea1i \u0111\u00e2y . Ngo\u00e0i ra, tai trang web tldp.org c\u00f3 m\u1ed9t chu\u1ed7i c\u00e1c b\u00e0i vi\u1ebft li\u00ean quan \u0111\u1ebfn ph\u00e1t tri\u1ec3n Kernel module ( The Linux Kernel Module Programming Guide ). C\u00f3 hai d\u1ea1ng Kernel module: build-in v\u00e0 loadable file. Trong \u0111\u00f3 built-in module \u0111\u01b0\u1ee3c t\u00edch h\u1ee3p v\u00e0o Kernel Image v\u00e0 \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng trong qu\u00e1 tr\u00ecnh kh\u1edfi \u0111\u1ed9ng kernel. Ng\u01b0\u1eddi l\u1ea1i, loadable module c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c ng\u01b0\u1eddi d\u00f9ng c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng sau khi kernel \u0111\u00e3 kh\u1edfi \u0111\u1ed9ng th\u00e0nh c\u00f4ng. Loadable Kernel Module (LKM) \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng b\u1eb1ng c\u00e1c c\u00e2u l\u1ec7nh nh\u01b0 modprobe ho\u1eb7c insmod.","title":"\u0110\u1ecbnh ngh\u0129a"},{"location":"ldd/overview/#module_init-module_exit","text":"Kernel module c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c hi\u1ec3u l\u00e0 m\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh ch\u1ea1y trong Kernel Space, nh\u01b0ng kh\u00f4ng gi\u1ed1ng nh\u01b0 ch\u01b0\u01a1ng tr\u00ecnh b\u00ecnh th\u01b0\u1eddng, kernel module kh\u00f4ng b\u1eaft \u0111\u1ea7u b\u1eb1ng h\u00e0m \"main\". Macro module_init() v\u00e0 module_exit() \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u0103ng k\u00fd c\u00e1c h\u00e0m kh\u1edfi t\u1ea1o v\u00e0 h\u00e0m h\u1ee7y cho kernel module. T\u00f9y thu\u1ed9c v\u00e0o kernel module l\u00e0 built-in hay LKM m\u00e0 n\u1ed9i d\u1ee5ng c\u1ee7a module_init/exit s\u1ebd kh\u00e1c nhau. Trong tr\u01b0\u1eddng h\u1ee3p l\u00e0 built-in module, module_init s\u1ebd g\u1ecdi \u0111\u1ebfn macro _init_call d\u00f9ng \u0111\u1ec3 \u0111\u0103ng k\u00fd v\u1edbi h\u1ec7 th\u1ed1ng l\u00e0 module s\u1ebd \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o tr\u1ecdng qu\u00e1 tr\u00ecnh init. Hai macro \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong linux/init.h.","title":"module_init &amp; module_exit"},{"location":"ldd/overview/#in-log-trong-kernel","text":"Ph\u01b0\u01a1ng ph\u00e1p debug c\u01a1 b\u1ea3n v\u00e0 ph\u1ed5 bi\u1ebfn nh\u1ea5t khi \u0111i ph\u00e1t tri\u1ec3n m\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh l\u00e0 in log ch\u1ea1y c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh \u0111\u00f3 ra m\u00e0n h\u00ecnh ho\u1eb7c file. Kernel module s\u1eed d\u1ee5ng l\u1ec7nh prink thay v\u00ec printf nh\u01b0 ph\u00e1t tri\u1ec3n \u1ee9ng d\u1ee5ng User space. Ngo\u00e0i ra c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng th\u00eam c\u00e1c h\u1ecd h\u00e0m dev_ v\u00e0 pr_ \u0111\u1ec3 in th\u00eam th\u00f4ng tin trong kernel module.","title":"In log trong kernel"},{"location":"ldd/overview/#cai-at-lkm-module-vao-he-thong","text":"\u0110\u1ec3 c\u00e0i \u0111\u1eb7t LKM v\u00e0o h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng l\u1ec7nh insmod/rmmod/lsmod . Ngo\u00e0i ra c\u00f3 th\u1ec3 d\u00f9ng th\u00eam modprobe. Qu\u00e1 tr\u00ecnh s\u1eed d\u1ee5ng modprobe ph\u1ee9c t\u1ea1p h\u01a1n insmod, c\u00f3 th\u1ec3 \u0111\u1ecdc th\u00eam [t\u1ea1i \u0111\u00e2y] . Trong qu\u00e1 tr\u00ecnh c\u00e0i \u0111\u1eb7t module v\u00e0o h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 th\u00eam c\u00e1c paramtters cho module. \u0110\u1ec3 li\u1ec7t k\u00ea to\u00e0n b\u1ed9 th\u00f4ng tin c\u1ee7a c\u00e1c module \u0111ang \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t trong h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng lsmod. Lsmod \u0111\u1ecdc th\u00f4ng tin t\u1eeb /proc/modules, ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 \u0111\u1ecdc tr\u1ef1c ti\u1ebfp t\u1eeb text file /proc/modules \u0111\u1ec3 bi\u1ebft th\u00eam \u0111\u01b0\u1ee3c th\u00f4ng tin c\u1ee7a c\u00e1c module \u0111ang ch\u1ea1y trong h\u1ec7 th\u1ed1ng. Khi m\u1ed9t module \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t v\u00e0o h\u1ec7 th\u1ed1ng, th\u00f4ng tin v\u1ec1 module n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y trong sysfs virtual file system /sys/module","title":"C\u00e0i \u0111\u1eb7t LKM module v\u00e0o h\u1ec7 th\u1ed1ng"},{"location":"ldd/overview/#compile-a-kernel-module","text":"\u0110\u1ec3 build m\u1ed9t kernel module, Linux Kernel s\u1eed d\u1ee5ng m\u1ed9t h\u1ec7 th\u1ed1ng g\u1ecdi l\u00e0 kbuild. C\u00f3 th\u1ec3 \u0111\u1ecdc th\u00eam th\u00f4ng tin v\u1ec1 h\u1ec7 th\u1ed1ng kbuild n\u00e0y trong Kernel Documentation ( kbuild/modules.txt ). Trong m\u1ee5c 2.2 c\u1ee7a [1] c\u00f3 gi\u1edbi thi\u1ec7u v\u1ec1 build kernel module.","title":"Compile a kernel module"},{"location":"ldd/overview/#character-device-driver","text":"Device Driver l\u00e0 m\u1ed9t kernel module, c\u00f3 ch\u1ee9c n\u0103ng giao ti\u1ebfp tr\u1ef1c ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng v\u00e0 cung c\u1ea5p c\u00e1c giao di\u1ec7n \u0111\u1ec3 c\u00e1c module kh\u00e1c c\u1ee7a kernel c\u0169ng nh\u01b0 user c\u00f3 th\u1ec3 truy c\u1eadp v\u00e0 s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean li\u00ean quan \u0111\u1ebfn c\u00e1c ph\u1ea7n c\u1ee9ng t\u01b0\u01a1ng \u1ee9ng. T\u00f9y thu\u1ed9c v\u00e0o lo\u1ea1i ph\u1ea7n c\u1ee9ng t\u01b0\u01a1ng \u1ee9ng m\u00e0 device driver \u0111\u01b0\u1ee3c chia ra l\u00e0m c\u00e1c lo\u1ea1i kh\u00e1c nhau. Trong t\u00e0i li\u1ec7u LDD3, device driver \u0111\u01b0\u1ee3c chia ra l\u00e0m 3 lo\u1ea1i ch\u00ednh: char module, block module v\u00e0 network module. Trong \u0111\u00f3 character device s\u1ebd \u0111\u01b0\u1ee3c t\u1eadp trung nghi\u00ean c\u1ee9u trong t\u00e0i li\u1ec7u n\u00e0y. Nh\u01b0 v\u1eady, m\u1ed9t device driver n\u00f3i chung c\u1ea7n th\u1ef1c hi\u1ec7n hai nhi\u1ec7m v\u1ee5 ch\u00ednh: Cung c\u1ea5p c\u00e1c giao di\u1ec7n \u0111\u1ec3 c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi User Space, qua \u0111\u00f3 c\u00e1c \u1ee9ng d\u1ee5ng c\u1ee7a ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi ph\u1ea7n c\u1ee9ng th\u00f4ng qua c\u00e1c giao di\u1ec7n n\u00e0y. Truy c\u1eadp \u0111\u1ebfn ph\u1ea7n c\u1ee9ng. Device driver \u0111\u01b0\u1ee3c sinh ra l\u00e0 \u0111\u1ec3 giao ti\u1ebfp tr\u1ef1c ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng. Trong t\u00e0i li\u1ec7u n\u00e0y s\u1ebd t\u00ecm hi\u1ec3u t\u1eebng nhi\u1ec7m v\u1ee5 tr\u00ean c\u1ee7a Device Driver.","title":"Character Device Driver"},{"location":"ldd/overview/#device-file","text":"Device file hay special file l\u00e0 m\u1ed9t giao di\u1ec7n \u0111\u1ec3 ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi device driver. Th\u00f4ng th\u01b0\u1eddng c\u00e1c device file xu\u1ea5t hi\u1ec7n trong /dev/ v\u00e0 \u0111\u01b0\u1ee3c qu\u1ea3n l\u00fd b\u1edfi virtual file system. Ng\u01b0\u1eddi d\u00f9ng th\u00f4ng qua c\u00e1c System Call \u0111\u1ec3 t\u01b0\u01a1ng t\u00e1c v\u1edbi device driver th\u00f4ng qua device file. C\u00e1c System Call li\u00ean quan \u0111\u1ebfn t\u01b0\u01a1ng t\u00e1c file \u0111\u01b0\u1ee3c x\u1eed l\u00fd b\u1edfi h\u1ec7 th\u1ed1ng VFS (Virtual File System) nh\u01b0: open(), close(), read(), write(), mmpa()... Qu\u00e1 tr\u00ecnh ho\u1ea1t \u0111\u1ed9ng c\u1ee7a c\u00e1c system call n\u00e0y \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 r\u00f5 trong Chapter 12: The Virtual File System c\u1ee7a s\u00e1ch Understanding Linux Kernel. V\u1eady v\u1edbi m\u1ed9t normal file, c\u00e1c ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 t\u00e1c \u0111\u1ed9ng g\u00ec \u0111\u01b0\u1ee3c? Th\u00f4ng tin n\u00e0y c\u00f3 th\u1ec3 t\u00ecm hi\u1ec3u qua t\u1eeb kh\u00f3a \"Working with file in C\".","title":"Device File"},{"location":"ldd/overview/#major-minor","text":"M\u1ed7i Device File trong /dev/ \u0111\u01b0\u1ee3c \u0111\u1eb7c tr\u01b0ng b\u1edfi hai tham s\u1ed1: Major, Minor . Major \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 x\u00e1c \u0111\u1ecbnh xem device \u0111\u00f3 t\u01b0\u01a1ng \u1ee9ng v\u1edbi driver n\u00e0o. Minor mang th\u00f4ng tin c\u1ee7a t\u1eebng thi\u1ebft b\u1ecb, v\u1ec1 c\u01a1 b\u1ea3n nhi\u1ec1u thi\u1ebft b\u1ecb c\u00f3 th\u1ec3 \u0111i\u1ec1u khi\u1ec3n b\u1eb1ng m\u1ed9t driver, do \u0111\u00f3 trong m\u1ed9t s\u1ed1 h\u1ec7 th\u1ed1ng, driver s\u1eed d\u1ee5ng Minor \u0111\u1ec3 ph\u00e2n bi\u1ec7t gi\u1eefa c\u00e1c thi\u1ebft b\u1ecb v\u1edbi nhau. Major v\u00e0 Minor t\u1ea1o th\u00e0nh m\u1ed9t c\u1eb7p s\u1ed1 unsigned \u0111\u1ec3 \u0111\u1eb7c tr\u01b0ng cho m\u1ed9t device, g\u1ecdi l\u00e0 Device Number. Kernel s\u1eed d\u1ee5ng ki\u1ec3u d\u1eef li\u1ec7u dev_t \u0111\u1ec3 m\u00f4 t\u1ea3 hai tham s\u1ed1 n\u00e0y. Dev_t \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong header linux/types d\u01b0\u1edbi d\u1ea1ng m\u1ed9t s\u1ed1 32 bit. typedef __u32 __kernel_dev_t; typedef __kernel_dev_t dev_t; Trong \u0111\u00f3, 20 bit th\u1ea5p \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho Minor v\u00e0 c\u00e1c bit cao c\u00f2n l\u1ea1i \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho Major. C\u00e1c macro s\u1eed d\u1ee5ng cho dev_t nh\u01b0 MKDEV, MAJOR, MINOR \u0111\u01b0\u1ee3c khai b\u00e1o trong linux/k_dev_t.h . C\u00f3 th\u1ec3 t\u1ea1o m\u1ed9t Device File \u0111\u01a1n gi\u1ea3n b\u1eb1ng Command: mknod /dev/coffee c 12 2 .","title":"Major &amp; Minor"},{"location":"ldd/overview/#khai-bao-mot-character-device-file","text":"","title":"Khai b\u00e1o m\u1ed9t Character Device File"},{"location":"ldd/overview/#cap-phat-device-number","text":"H\u00e0m register_chrdev_region() \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u0103ng k\u00fd device number. int register_chrdev_region(dev_t from, unsigned count, const char *name); Qu\u00e1 tr\u00ecnh n\u00e0y l\u00e0 c\u1ea5p ph\u00e1t t\u0129nh dev_t, trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p y\u00eau c\u1ea7u c\u1ea5p ph\u00e1t n\u00e0y kh\u00f4ng th\u00e0nh c\u00f4ng do y\u00eau c\u1ea7u c\u1ee7a driver kh\u00f4ng ph\u00f9 h\u1ee3p v\u1edbi y\u00eau c\u1ea7u hi\u1ec7n t\u1ea1i c\u1ee7a h\u1ec7 th\u1ed1ng. Trong tr\u01b0\u1eddng h\u1ee3p \u0111\u00f3 c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng h\u00e0m alloc_chrdev_region() . Nguy\u00ean m\u1eabu c\u1ee7a h\u00e0m \u0111\u00f3 nh\u01b0 sau: int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,*const char *name); K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh c\u1ea5p ph\u00e1t device number l\u00e0 Major v\u00e0 m\u1ed9t d\u1ea3i Minor m\u00e0 driver c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng.","title":"C\u1ea5p ph\u00e1t Device Number"},{"location":"ldd/overview/#ang-ky-character-device-file","text":"Kernel s\u1eed d\u1ee5ng m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1ec3 l\u01b0u gi\u1eef th\u00f4ng tin c\u1ee7a m\u1ed9t character device: struct cdev. Struct cdev \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong linux/cdev.h bao g\u1ed3m c\u00e1c tr\u01b0\u1eddng th\u00f4ng tin \u1edf b\u1ea3ng sau. structcdev{ struct kobject kobj; struct module *owner; const struct file_operations *ops; struct list_head list; dev_t dev; unsigned int count; } __randomize_layout; M\u1ed7i char device t\u01b0\u01a1ng \u1ee9ng v\u1edbi m\u1ed9t device number dev_t v\u00e0 c\u00f3 c\u00e1c file_operations t\u01b0\u1edbng \u1ee9ng. C\u00e1c file_operations (\u0111\u1ecbnh ngh\u0129a trong linux/fs.h ) \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 trong b\u1ea3ng sau. struct file_operations { ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); int (*mmap) (struct file *, struct vm_area_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); [some feilds obmitted] } __randomize_layout;","title":"\u0110\u0103ng k\u00fd Character Device File"},{"location":"ldd/overview/#cdev_init-cdev_add","text":"Tr\u01b0\u1edbc khi kh\u1edfi t\u1ea1o v\u00e0 \u0111\u0103ng k\u00fd m\u1ed9t cdev v\u1edbi kernel, m\u1ed9t v\u00f9ng nh\u1edb s\u1eed d\u1ee5ng cho bi\u1ebfn cdev n\u00e0y ph\u1ea3i \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o. Ph\u01b0\u01a1ng ph\u00e1p \u0111\u01a1n gi\u1ea3n nh\u1ea5t l\u00e0 khai b\u00e1o m\u1ed9t bi\u1ebfn to\u00e0n c\u1ee5c trong driver. Qu\u00e1 tr\u00ecnh cdev_init b\u1ea3n ch\u1ea5t l\u00e0 trang b\u1ecb file_openratons cho cdev v\u00e0 th\u00eam n\u00f3 v\u00e0o danh s\u00e1ch c\u00e1c thi\u1ebft b\u1ecb \u0111\u00e3 \u0111\u01b0\u1ee3c khai b\u00e1o trong h\u1ec7 th\u1ed1ng. H\u00e0m cdev_add ti\u1ebfn h\u00e0nh th\u00eam cdev v\u00e0o h\u1ec7 th\u1ed1ng. L\u01b0u \u00fd nguy\u00ean m\u1eabu h\u00e0m cdev_add nh\u01b0 sau: int cdev_add(struct cdev *p, dev_t dev, unsigned count); Trong \u0111\u00f3 con tr\u1ecf p \u0111\u01b0\u1ee3c tr\u1ecf \u0111\u1ebfn bi\u1ebfn cdev \u0111\u00e3 \u0111\u01b0\u1ee3c khai b\u00e1o, v\u00e0 dev_t dev l\u00e0 device number \u0111\u1ea7u ti\u00ean trong d\u00e3y c\u00e1c device number li\u00ean quan \u0111\u1ebfn cdev n\u00e0y, count l\u00e0 s\u1ed1 l\u01b0\u1ee3ng c\u00e1c minor number li\u00ean ti\u1ebfp sau MINOR(dev_t dev) li\u00ean quan \u0111\u1ebfn device n\u00e0y. Gi\u1ea3 s\u1eed ta ti\u1ebfn h\u00e0nh th\u00eam m\u1ed9t cdev nh\u01b0 sau: struct cdev mycdev; dev_t mydevno = MKDEV(246, 0); cdev_add(mycdev, mydevno, 4); V\u00e0 sau \u0111\u00f3 kh\u1edfi t\u1ea1o th\u00eam 4 files. mknod /dev/scull0 c 246 0 mknod /dev/scull1 c 246 1 mknod /dev/scull2 c 246 2 mknod /dev/scull3 c 246 3 Khi ti\u1ebfn h\u00e0nh \u0111\u1ecdc ghi c\u00e1c /dev/file n\u00e0y \u0111\u1ec3u tr\u1ea3 v\u1ec1 m\u1ed9t dev_t duy nh\u1ea5t 246, 0 .","title":"cdev_init &amp; cdev_add"},{"location":"ldd/overview/#mutex","text":"http://derekmolloy.ie/writing-a-linux-kernel-module-part-2-a-character-device/","title":"Mutex"},{"location":"ldd/overview/#mmap","text":"https://nhauyeneducation.blogspot.com/2018/11/hieu-ve-to-chuc-bo-nho-linux-thong-qua.html?fbclid=IwAR2w4W3yttmtqbZYqcwzTQ95Qvs92ZXDdBXns9kgO7IeokpVvoc8OY3IVLo https://linux-kernel-labs.github.io/master/labs/memory_mapping.html","title":"MMAP"},{"location":"ldd/overview/#ioctl","text":"https://ufal.mff.cuni.cz/~jernej/2018/docs/predavanja06.pdf Ioctl - Input Output Control \u0111\u01b0\u1ee3c sinh ra \u0111\u1ec3 h\u1ed7 tr\u1ee3 ng\u01b0\u1eddi d\u00f9ng khai b\u00e1o th\u00eam c\u00e1c c\u00e2u l\u1ec7nh m\u1edbi ph\u00f9 h\u1ee3p v\u1edbi t\u1eebng d\u00f2ng thi\u1ebft b\u1ecb. Trong v\u00ed d\u1ee5 li\u00ean quan \u0111\u1ebfn b\u00e0i \u0111\u00e0o t\u1ea1o, led_controller_core c\u00f3 hai tham s\u1ed1 c\u00f3 th\u1ec3 c\u1ea5u h\u00ecnh \u0111\u01b0\u1ee3c trong qu\u00e1 tr\u00ecnh ch\u1ea1y: SPEED: T\u1ed1c \u0111\u1ed9 LED. POSITION: V\u1ecb tr\u00ed LED nh\u00e1y. - M\u1ee5c ti\u00eau c\u1ea7n ph\u1ea3i \u0111\u1ecbnh ngh\u0129a \u0111\u01b0\u1ee3c m\u1ed9t s\u1ed1 c\u00e2u l\u1ec7nh \u0111\u1ec3 l\u00e0m v\u00ed d\u1ee5 trong qu\u00e1 tr\u00ecnh ph\u00e1t tri\u1ec3n.","title":"IOCTL"},{"location":"ldd/overview/#giao-tiep-voi-phan-cung","text":"","title":"Giao ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng"},{"location":"ldd/overview/#platform-device","text":"Giao ti\u1ebfp v\u1edbi ph\u1ea7n c\u1ee9ng trong m\u1ed9t h\u1ec7 nh\u00fang r\u1ea5t \u0111a d\u1ea1ng. Ph\u01b0\u01a1ng ph\u00e1p giao ti\u1ebfp v\u1edbi ph\u1ea7n t\u1eed trong h\u1ec7 nh\u00fang ph\u1ee5 thu\u1ed9c v\u00e0o lo\u1ea1i thi\u1ebft b\u1ecb c\u1ee7a ph\u1ea7n t\u1eed \u0111\u00f3. Trong ph\u1ea1m vi b\u00e0i vi\u1ebft n\u00e0y s\u1ebd t\u01b0\u01a1ng t\u00e1c v\u1edbi m\u1ed9t lo\u1ea1i thi\u1ebft b\u1ecb: platform_device.","title":"Platform Device"},{"location":"ldd/overview/#struct-resource","text":"platform_get_resource th\u1ef1c hi\u1ec7n t\u00ecm ki\u1ebfm t\u1ea5t c\u1ea3 c\u00e1c resource hi\u1ec7n t\u1ea1i c\u00f3 trong platform_device. Qu\u00e1 tr\u00ecnh t\u00ecm ki\u1ebfm d\u1ef1a v\u00e0o lo\u1ea1i resource \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong linux/ioport.h. C\u00e1c lo\u1ea1i resource c\u01a1 b\u1ea3n nh\u01b0: IORESOURCE_MEM (memory) IORESOURCE_IRQ (interupt)","title":"struct resource"},{"location":"ldd/gpio/gpio/","text":"General Purpose Input or Output Driver perspective V\u1ec1 c\u01a1 b\u1ea3n, c\u00e1c subsytem c\u1ee7a Linux Kernel nh\u01b0 SPI, I2C, GPIO ... \u0111\u1ec1u ho\u1ea1t \u0111\u1ed9ng v\u1edbi m\u00f4 h\u00ecnh (concept) t\u01b0\u01a1ng t\u1ef1 nhau. C\u00e1c t\u00e0i nguy\u00ean ph\u1ea7n c\u1ee9ng \u0111\u01b0\u1ee3c \u0111\u0103ng k\u00fd v\u1edbi Kernel, c\u00e1c module kh\u00e1c c\u1ee7a Kernel mu\u1ed1n truy c\u1eadp \u0111\u1ebfn c\u00e1c ph\u1ea7n c\u1ee9ng n\u00e0y s\u1ebd c\u1ea7n ph\u1ea3i g\u1eedi y\u00eau c\u1ea7u. GPIO Controlller Driver : th\u1ef1c hi\u1ec7n \u0111\u0103ng k\u00fd m\u1ed9t struct gpio_chip v\u1edbi Linux kernel, khai b\u00e1o c\u00e1c t\u00e0i nguy\u00ean c\u00f3 th\u1ec3 cung c\u1ea5p \u0111\u01b0\u1ee3c c\u1ee7a GPIO controller. gpio_chip cung c\u1ea5p c\u00e1c ph\u01b0\u01a1ng th\u1ee9c nh\u01b0 request , set , get ... v\u00e0 th\u00f4ng qua c\u00e1c ph\u01b0\u01a1ng th\u1ee9c n\u00e0y c\u00f3 th\u1ec3 t\u00e1c \u0111\u1ed9ng \u0111\u1ebfn ph\u1ea7n c\u1ee9ng GPIO. gpio@e000a000 { compatible = xlnx,zynq-gpio-1.0 ; #gpio-cells = 0x2 ; clocks = 0x1 0x2a ; gpio-controller; interrupt-parent = 0x3 ; interrupts = 0x0 0x14 0x4 ; reg = 0xe000a000 0x1000 ; ... }; Zynq GPIO Controller is described as a node in Device Tree . User modules : c\u00e1c module kh\u00e1c trong trong tr\u01b0\u1eddng h\u1ee3p mu\u1ed1n s\u1eed d\u1ee5ng m\u1ed9t pin GPIO thu\u1ed9c quy\u1ec1n qu\u1ea3n l\u00fd c\u1ee7a GPIO Controller s\u1ebd g\u1eedi y\u00eau c\u1ea7u \u0111\u1ebfn kernel \u0111\u1ec3 xin t\u00e0i nguy\u00ean. GPIO Subsystem cung c\u1ea5p c\u00e1c APIs nh\u01b0 gpio_request_one v\u00e0 gpio_request_array \u0111\u1ec3 c\u00e1c module c\u00f3 th\u1ec3 y\u00eau c\u1ea7u t\u00e0i nguy\u00ean. N\u1ebfu qu\u00e1 tr\u00ecnh y\u00eau c\u1ea7u t\u00e0i nguy\u00ean th\u00e0nh c\u00f4ng, module s\u1ebd \u0111i\u1ec1u khi\u1ec3n GPIO th\u00f4ng qua c\u00e1c APIs nh\u01b0 gpio_set_value v\u00e0 gpio_get_value . Li\u00ean k\u1ebft gi\u1eefa Other module v\u00e0 Controller driver : gpio_number -1- struct gpio_desc * -2- struct gpio_chip * Qu\u00e1 tr\u00ecnh 1, t\u1eeb gpio_number c\u00f3 th\u1ec3 g\u1ecdi \u0111\u1ebfn gpio_desc b\u1eb1ng c\u00e1c API nh\u01b0 gpio_to_desc . V\u1ec1 b\u1ea3n ch\u1ea5t, gpio_desc \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef b\u1eb1ng m\u1ed9t m\u1ea3ng t\u0129nh: static struct gpio_desc gpio_desc[ARCH_NR_GPIOS]; trong \u0111\u00f3 gpio_number l\u00e0 ch\u1ec9 s\u1ed1 c\u1ee7a m\u1ea3ng t\u0129nh n\u00e0y, do \u0111\u00f3 truy c\u1eadp \u0111\u1ebfn gpio_desc c\u1ee7a m\u1ed9t gpio_number \u0111\u01a1n gi\u1ea3n l\u00e0 truy c\u1eadp \u0111\u1ebfn m\u1ed9t ph\u1ea7n t\u1eed c\u1ee7a m\u1ea3ng. Qu\u00e1 tr\u00ecnh 2, gpio_desc ch\u1ee9a con tr\u1ecf tr\u1ecf \u0111\u1ebfn struct gpio_chip *chip; , do \u0111\u00f3 t\u1eeb gpio_desc c\u00f3 th\u1ec3 d\u1ec5 d\u00e0ng truy c\u1eadp \u0111\u01b0\u1ee3c \u0111\u1ebfn gpio_chip (desc- chip). Quy tr\u00ecnh g\u1eedi y\u00eau c\u1ea7u v\u00e0 s\u1eed d\u1ee5ng GPIO \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 trong m\u1ed9t t\u00e0i li\u1ec7u khoa h\u1ecdc trong m\u1ee5c References. Userspace software perspective Truy c\u1eadp tr\u1ef1c ti\u1ebfp t\u1eeb c\u00e1c device attribute trong sysfs GPIO Class Trong gpiolib-sysfs.c khai b\u00e1o struct class gpio_class trong h\u00e0m __init : status = class_register( gpio_class); V\u1edbi thu\u1ed9c t\u00ednh gpio_class_attrs : static struct class_attribute gpio_class_attrs[] = { __ATTR(export, 0200, NULL, export_store), __ATTR(unexport, 0200, NULL, unexport_store), __ATTR_NULL, }; static struct class gpio_class = { .name = gpio , .owner = THIS_MODULE, .class_attrs = gpio_class_attrs, }; K\u1ebft qu\u1ea3 trong sys/class/gpio/ xu\u1ea5t hi\u1ec7n hai thu\u1ed9c t\u00ednh export/unexport . /sys/class/gpio# ls -l --w------- 1 root root 4096 Jan 1 00:00 export lrwxrwxrwx 1 root root 0 Jan 1 00:00 gpiochip0 - ../../devices/soc0/amba/e000a000.gpio/gpio/gpiochip0 --w------- 1 root root 4096 Jan 1 00:00 unexport Hai thu\u1ed9c t\u00ednh export/unexport \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 y\u00eau c\u1ea7u/h\u1ee7y y\u00eau c\u1ea7u \u0111\u1ed1i v\u1edbi m\u1ed9t GPIO. GPIO controller device Trong qu\u00e1 tr\u00ecnh controller driver \u0111\u0103ng k\u00fd GPIO v\u1edbi Kernel (gpiolib), c\u00e1c attribute c\u1ee7a gpiochip device \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o th\u00f4ng qua int gpiochip_export(struct gpio_chip *chip) . K\u1ebft qu\u1ea3 l\u00e0 m\u1ed9t device \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o: /sys/devices/soc0/amba/e000a000.gpio/gpio/gpiochip0 C\u00e1c thu\u1ed9c t\u00ednh b\u00ean trong device n\u00e0y c\u00f3 d\u1ea1ng nh\u01b0 sau -r--r--r-- 1 root root 4096 Jan 1 00:00 base lrwxrwxrwx 1 root root 0 Jan 1 00:00 device - ../../../e000a000.gpio -r--r--r-- 1 root root 4096 Jan 1 00:00 label -r--r--r-- 1 root root 4096 Jan 1 00:00 ngpio drwxr-xr-x 2 root root 0 Jan 1 00:00 power lrwxrwxrwx 1 root root 0 Jan 1 00:00 subsystem - ../../../../../../class/gpio -rw-r--r-- 1 root root 4096 Jan 1 00:00 uevent GPIO Pin Device \u0110\u1ec3 c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng \u0111\u01b0\u1ee3c m\u1ed9t pin GPIO, c\u1ea7n c\u00f3 qu\u00e1 tr\u00ecnh g\u1eedi y\u00eau c\u1ea7u \u0111\u1ebfn h\u1ec7 th\u1ed1ng. Qu\u00e1 tr\u00ecnh n\u00e0y c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng th\u00f4ng qua API gpio_request_array ho\u1eb7c s\u1eed d\u1ee5ng c\u00e1c attributes export/unexport . V\u1ec1 c\u01a1 b\u1ea3n hai qu\u00e1 tr\u00ecnh n\u00e0y s\u1ebd th\u1ef1c hi\u1ec7n g\u1ecdi \u0111\u1ebfn API int gpiod_export(struct gpio_desc *desc, bool direction_may_change) \u0111\u1ec3 t\u1ea1o ra c\u00e1c GPIO device. dev = device_create( gpio_class, desc- chip- dev, MKDEV(0, 0), desc, ioname ? ioname : gpio%u , desc_to_gpio(desc)); V\u00ed d\u1ee5 v\u1edbi gpioN, device xu\u1ea5t hi\u1ec7n trong h\u1ec7 th\u1ed1ng nh\u01b0 sau: /sys/devices/soc0/amba/e000a000.gpio/gpio/gpioN C\u00e1c thu\u1ed9c t\u00ednh \u0111\u00f3 bao g\u1ed3m: /sys/devices/soc0/amba/e000a000.gpio/gpio/gpio1# ls -l -rw-r--r-- 1 root root 4096 Jan 3 22:42 active_low lrwxrwxrwx 1 root root 0 Jan 3 22:42 device - ../../../e000a000.gpio -rw-r--r-- 1 root root 4096 Jan 3 22:42 direction -rw-r--r-- 1 root root 4096 Jan 3 22:42 edge drwxr-xr-x 2 root root 0 Jan 3 22:42 power lrwxrwxrwx 1 root root 0 Jan 3 22:42 subsystem - ../../../../../../class/gpio -rw-r--r-- 1 root root 4096 Jan 3 22:42 uevent -rw-r--r-- 1 root root 4096 Jan 3 22:42 value Truy c\u1eadp th\u00f4ng qua c\u00e1c user module V\u1ec1 c\u01a1 b\u1ea3n, qu\u00e1 tr\u00ecnh truy c\u1eadp m\u1ed9t ch\u00e2n GPIO th\u00f4ng qua m\u1ed9t user module c\u0169ng \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n t\u01b0\u01a1ng t\u1ef1 nh\u01b0 truy c\u1eadp tr\u1ef1c ti\u1ebfp qua c\u00e1c thu\u1ed9c t\u00ednh c\u1ee7a gpio class v\u00e0 gpio device . Qu\u00e1 tr\u00ecnh n\u00e0y ch\u1ec9 kh\u00e1c nhau \u1edf ph\u01b0\u01a1ng th\u1ee9c giao ti\u1ebfp gi\u1eefa User Space v\u00e0 Kernel Space. Thay v\u00ec tr\u1ef1c ti\u1ebfp s\u1eed d\u1ee5ng c\u00e1c thu\u1ed9c t\u00ednh c\u1ee7a gpio class th\u00ec c\u00e1c \u1ee9ng d\u1ee5ng user space s\u1ebd t\u01b0\u01a1ng t\u00e1c qua c\u00e1c thu\u1ed9c t\u00ednh c\u1ee7a User module (c\u00f3 th\u1ec3 l\u00e0 IOCTL ho\u1eb7c device attributes). Hardware perspective Zynq7000 In Zynq, GPIO controller registers are memory mapped at base address 0xe000a000. Figure. GPIO pin in Zynq7000 References GPIO in the kernel: an introduction - lwn.net","title":"GPIO"},{"location":"ldd/gpio/gpio/#general-purpose-input-or-output","text":"","title":"General Purpose Input or Output"},{"location":"ldd/gpio/gpio/#driver-perspective","text":"V\u1ec1 c\u01a1 b\u1ea3n, c\u00e1c subsytem c\u1ee7a Linux Kernel nh\u01b0 SPI, I2C, GPIO ... \u0111\u1ec1u ho\u1ea1t \u0111\u1ed9ng v\u1edbi m\u00f4 h\u00ecnh (concept) t\u01b0\u01a1ng t\u1ef1 nhau. C\u00e1c t\u00e0i nguy\u00ean ph\u1ea7n c\u1ee9ng \u0111\u01b0\u1ee3c \u0111\u0103ng k\u00fd v\u1edbi Kernel, c\u00e1c module kh\u00e1c c\u1ee7a Kernel mu\u1ed1n truy c\u1eadp \u0111\u1ebfn c\u00e1c ph\u1ea7n c\u1ee9ng n\u00e0y s\u1ebd c\u1ea7n ph\u1ea3i g\u1eedi y\u00eau c\u1ea7u. GPIO Controlller Driver : th\u1ef1c hi\u1ec7n \u0111\u0103ng k\u00fd m\u1ed9t struct gpio_chip v\u1edbi Linux kernel, khai b\u00e1o c\u00e1c t\u00e0i nguy\u00ean c\u00f3 th\u1ec3 cung c\u1ea5p \u0111\u01b0\u1ee3c c\u1ee7a GPIO controller. gpio_chip cung c\u1ea5p c\u00e1c ph\u01b0\u01a1ng th\u1ee9c nh\u01b0 request , set , get ... v\u00e0 th\u00f4ng qua c\u00e1c ph\u01b0\u01a1ng th\u1ee9c n\u00e0y c\u00f3 th\u1ec3 t\u00e1c \u0111\u1ed9ng \u0111\u1ebfn ph\u1ea7n c\u1ee9ng GPIO. gpio@e000a000 { compatible = xlnx,zynq-gpio-1.0 ; #gpio-cells = 0x2 ; clocks = 0x1 0x2a ; gpio-controller; interrupt-parent = 0x3 ; interrupts = 0x0 0x14 0x4 ; reg = 0xe000a000 0x1000 ; ... }; Zynq GPIO Controller is described as a node in Device Tree . User modules : c\u00e1c module kh\u00e1c trong trong tr\u01b0\u1eddng h\u1ee3p mu\u1ed1n s\u1eed d\u1ee5ng m\u1ed9t pin GPIO thu\u1ed9c quy\u1ec1n qu\u1ea3n l\u00fd c\u1ee7a GPIO Controller s\u1ebd g\u1eedi y\u00eau c\u1ea7u \u0111\u1ebfn kernel \u0111\u1ec3 xin t\u00e0i nguy\u00ean. GPIO Subsystem cung c\u1ea5p c\u00e1c APIs nh\u01b0 gpio_request_one v\u00e0 gpio_request_array \u0111\u1ec3 c\u00e1c module c\u00f3 th\u1ec3 y\u00eau c\u1ea7u t\u00e0i nguy\u00ean. N\u1ebfu qu\u00e1 tr\u00ecnh y\u00eau c\u1ea7u t\u00e0i nguy\u00ean th\u00e0nh c\u00f4ng, module s\u1ebd \u0111i\u1ec1u khi\u1ec3n GPIO th\u00f4ng qua c\u00e1c APIs nh\u01b0 gpio_set_value v\u00e0 gpio_get_value . Li\u00ean k\u1ebft gi\u1eefa Other module v\u00e0 Controller driver : gpio_number -1- struct gpio_desc * -2- struct gpio_chip * Qu\u00e1 tr\u00ecnh 1, t\u1eeb gpio_number c\u00f3 th\u1ec3 g\u1ecdi \u0111\u1ebfn gpio_desc b\u1eb1ng c\u00e1c API nh\u01b0 gpio_to_desc . V\u1ec1 b\u1ea3n ch\u1ea5t, gpio_desc \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef b\u1eb1ng m\u1ed9t m\u1ea3ng t\u0129nh: static struct gpio_desc gpio_desc[ARCH_NR_GPIOS]; trong \u0111\u00f3 gpio_number l\u00e0 ch\u1ec9 s\u1ed1 c\u1ee7a m\u1ea3ng t\u0129nh n\u00e0y, do \u0111\u00f3 truy c\u1eadp \u0111\u1ebfn gpio_desc c\u1ee7a m\u1ed9t gpio_number \u0111\u01a1n gi\u1ea3n l\u00e0 truy c\u1eadp \u0111\u1ebfn m\u1ed9t ph\u1ea7n t\u1eed c\u1ee7a m\u1ea3ng. Qu\u00e1 tr\u00ecnh 2, gpio_desc ch\u1ee9a con tr\u1ecf tr\u1ecf \u0111\u1ebfn struct gpio_chip *chip; , do \u0111\u00f3 t\u1eeb gpio_desc c\u00f3 th\u1ec3 d\u1ec5 d\u00e0ng truy c\u1eadp \u0111\u01b0\u1ee3c \u0111\u1ebfn gpio_chip (desc- chip). Quy tr\u00ecnh g\u1eedi y\u00eau c\u1ea7u v\u00e0 s\u1eed d\u1ee5ng GPIO \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 trong m\u1ed9t t\u00e0i li\u1ec7u khoa h\u1ecdc trong m\u1ee5c References.","title":"Driver perspective"},{"location":"ldd/gpio/gpio/#userspace-software-perspective","text":"Truy c\u1eadp tr\u1ef1c ti\u1ebfp t\u1eeb c\u00e1c device attribute trong sysfs GPIO Class Trong gpiolib-sysfs.c khai b\u00e1o struct class gpio_class trong h\u00e0m __init : status = class_register( gpio_class); V\u1edbi thu\u1ed9c t\u00ednh gpio_class_attrs : static struct class_attribute gpio_class_attrs[] = { __ATTR(export, 0200, NULL, export_store), __ATTR(unexport, 0200, NULL, unexport_store), __ATTR_NULL, }; static struct class gpio_class = { .name = gpio , .owner = THIS_MODULE, .class_attrs = gpio_class_attrs, }; K\u1ebft qu\u1ea3 trong sys/class/gpio/ xu\u1ea5t hi\u1ec7n hai thu\u1ed9c t\u00ednh export/unexport . /sys/class/gpio# ls -l --w------- 1 root root 4096 Jan 1 00:00 export lrwxrwxrwx 1 root root 0 Jan 1 00:00 gpiochip0 - ../../devices/soc0/amba/e000a000.gpio/gpio/gpiochip0 --w------- 1 root root 4096 Jan 1 00:00 unexport Hai thu\u1ed9c t\u00ednh export/unexport \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 y\u00eau c\u1ea7u/h\u1ee7y y\u00eau c\u1ea7u \u0111\u1ed1i v\u1edbi m\u1ed9t GPIO. GPIO controller device Trong qu\u00e1 tr\u00ecnh controller driver \u0111\u0103ng k\u00fd GPIO v\u1edbi Kernel (gpiolib), c\u00e1c attribute c\u1ee7a gpiochip device \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o th\u00f4ng qua int gpiochip_export(struct gpio_chip *chip) . K\u1ebft qu\u1ea3 l\u00e0 m\u1ed9t device \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o: /sys/devices/soc0/amba/e000a000.gpio/gpio/gpiochip0 C\u00e1c thu\u1ed9c t\u00ednh b\u00ean trong device n\u00e0y c\u00f3 d\u1ea1ng nh\u01b0 sau -r--r--r-- 1 root root 4096 Jan 1 00:00 base lrwxrwxrwx 1 root root 0 Jan 1 00:00 device - ../../../e000a000.gpio -r--r--r-- 1 root root 4096 Jan 1 00:00 label -r--r--r-- 1 root root 4096 Jan 1 00:00 ngpio drwxr-xr-x 2 root root 0 Jan 1 00:00 power lrwxrwxrwx 1 root root 0 Jan 1 00:00 subsystem - ../../../../../../class/gpio -rw-r--r-- 1 root root 4096 Jan 1 00:00 uevent GPIO Pin Device \u0110\u1ec3 c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng \u0111\u01b0\u1ee3c m\u1ed9t pin GPIO, c\u1ea7n c\u00f3 qu\u00e1 tr\u00ecnh g\u1eedi y\u00eau c\u1ea7u \u0111\u1ebfn h\u1ec7 th\u1ed1ng. Qu\u00e1 tr\u00ecnh n\u00e0y c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng th\u00f4ng qua API gpio_request_array ho\u1eb7c s\u1eed d\u1ee5ng c\u00e1c attributes export/unexport . V\u1ec1 c\u01a1 b\u1ea3n hai qu\u00e1 tr\u00ecnh n\u00e0y s\u1ebd th\u1ef1c hi\u1ec7n g\u1ecdi \u0111\u1ebfn API int gpiod_export(struct gpio_desc *desc, bool direction_may_change) \u0111\u1ec3 t\u1ea1o ra c\u00e1c GPIO device. dev = device_create( gpio_class, desc- chip- dev, MKDEV(0, 0), desc, ioname ? ioname : gpio%u , desc_to_gpio(desc)); V\u00ed d\u1ee5 v\u1edbi gpioN, device xu\u1ea5t hi\u1ec7n trong h\u1ec7 th\u1ed1ng nh\u01b0 sau: /sys/devices/soc0/amba/e000a000.gpio/gpio/gpioN C\u00e1c thu\u1ed9c t\u00ednh \u0111\u00f3 bao g\u1ed3m: /sys/devices/soc0/amba/e000a000.gpio/gpio/gpio1# ls -l -rw-r--r-- 1 root root 4096 Jan 3 22:42 active_low lrwxrwxrwx 1 root root 0 Jan 3 22:42 device - ../../../e000a000.gpio -rw-r--r-- 1 root root 4096 Jan 3 22:42 direction -rw-r--r-- 1 root root 4096 Jan 3 22:42 edge drwxr-xr-x 2 root root 0 Jan 3 22:42 power lrwxrwxrwx 1 root root 0 Jan 3 22:42 subsystem - ../../../../../../class/gpio -rw-r--r-- 1 root root 4096 Jan 3 22:42 uevent -rw-r--r-- 1 root root 4096 Jan 3 22:42 value Truy c\u1eadp th\u00f4ng qua c\u00e1c user module V\u1ec1 c\u01a1 b\u1ea3n, qu\u00e1 tr\u00ecnh truy c\u1eadp m\u1ed9t ch\u00e2n GPIO th\u00f4ng qua m\u1ed9t user module c\u0169ng \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n t\u01b0\u01a1ng t\u1ef1 nh\u01b0 truy c\u1eadp tr\u1ef1c ti\u1ebfp qua c\u00e1c thu\u1ed9c t\u00ednh c\u1ee7a gpio class v\u00e0 gpio device . Qu\u00e1 tr\u00ecnh n\u00e0y ch\u1ec9 kh\u00e1c nhau \u1edf ph\u01b0\u01a1ng th\u1ee9c giao ti\u1ebfp gi\u1eefa User Space v\u00e0 Kernel Space. Thay v\u00ec tr\u1ef1c ti\u1ebfp s\u1eed d\u1ee5ng c\u00e1c thu\u1ed9c t\u00ednh c\u1ee7a gpio class th\u00ec c\u00e1c \u1ee9ng d\u1ee5ng user space s\u1ebd t\u01b0\u01a1ng t\u00e1c qua c\u00e1c thu\u1ed9c t\u00ednh c\u1ee7a User module (c\u00f3 th\u1ec3 l\u00e0 IOCTL ho\u1eb7c device attributes).","title":"Userspace software perspective"},{"location":"ldd/gpio/gpio/#hardware-perspective","text":"Zynq7000 In Zynq, GPIO controller registers are memory mapped at base address 0xe000a000. Figure. GPIO pin in Zynq7000","title":"Hardware perspective"},{"location":"ldd/gpio/gpio/#references","text":"GPIO in the kernel: an introduction - lwn.net","title":"References"},{"location":"ldd/platform_dev/platform_device/","text":"","title":"Platform Device"},{"location":"ldd/spi_dev/spi_advance/","text":"Advanced SPI Extend number of CS signal SPI GPIO","title":"SPI Device Advance"},{"location":"ldd/spi_dev/spi_advance/#advanced-spi","text":"","title":"Advanced SPI"},{"location":"ldd/spi_dev/spi_advance/#extend-number-of-cs-signal","text":"","title":"Extend number of CS signal"},{"location":"ldd/spi_dev/spi_advance/#spi-gpio","text":"","title":"SPI GPIO"},{"location":"ldd/spi_dev/spi_dev/","text":"SPI Device Driver Hanoi - Tuesday, January 29, 2019 - by VuTang Introduction SPI l\u00e0 chu\u1ea9n giao ti\u1ebfp n\u1ed1i ti\u1ebfp d\u1ef1a tr\u00ean m\u00f4 h\u00ecnh Master-Slaves, trong \u0111\u00f3 m\u1ed9t master c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i \u0111\u1ebfn m\u1ed9t ho\u1eb7c nhi\u1ec1u thi\u1ebft b\u1ecb slave. M\u1ed9t bus SPI th\u00f4ng th\u01b0\u1eddng c\u00f3 4 t\u00edn hi\u1ec7u: SCLK: clock d\u00f9ng cho \u0111\u1ed3ng b\u1ed9 t\u00edn hi\u1ec7u SS: Slave Select, d\u00f9ng \u0111\u1ec3 \u0111\u00e1nh d\u1ea5u thi\u1ebft b\u1ecb Slave n\u00e0o \u0111\u01b0\u1ee3c active \u0111\u1ec3 trao \u0111\u1ed5i d\u1eef li\u1ec7u. Pin n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c g\u1ecdi b\u1eb1ng c\u00e1c t\u00ean kh\u00e1c nh\u01b0: CS (chip sellect), LE (Latch Enable), \u2026 T\u00edn hi\u1ec7u SS th\u00f4ng th\u01b0\u1eddng active m\u1ee9c th\u1ea5p. MISO: d\u1eef li\u1ec7u v\u00e0o c\u1ee7a master MOSI: d\u1eef li\u1ec7u ra c\u1ee7a master. Trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p, pin MISO/MOSI c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng chung tr\u00ean m\u1ed9t \u0111\u01b0\u1eddng t\u00edn hi\u1ec7u \u0111\u1ea3m nhi\u1ec7m c\u1ea3 hai ch\u1ee9c n\u0103ng in/out. Figure. SPI bus signals SPI Subsystem in Linux C\u00e1c ki\u1ebfn th\u1ee9c trong technote n\u00e0y \u0111\u01b0\u1ee3c kh\u00e1i qu\u00e1t h\u00f3a sau qu\u00e1 tr\u00ecnh t\u00ecm hi\u1ec3u h\u1ec7 th\u1ed1ng SPI s\u1eed d\u1ee5ng Cadence Controller v\u00e0 SPI-GPIO, do \u0111\u00f3 c\u00f3 th\u1ec3 kh\u00f4ng mang \u0111\u01b0\u1ee3c t\u00ednh t\u1ed5ng qu\u00e1t h\u00f3a l\u00ean to\u00e0n b\u1ed9 c\u00e1c thi\u1ebft b\u1ecb SPI. spi.h : defines important data structures what are used for SPI subsystem. spi.c : SPI core APIs are implemented in this file. SPI Device Driver Model Trong Figure 1 th\u1ec3 hi\u1ec7n m\u00f4 h\u00ecnh c\u1ee7a m\u1ed9t h\u1ec7 th\u1ed1ng SPI trong Linux, bao g\u1ed3m: V\u1ec1 ph\u1ea7n c\u1ee9ng, m\u1ed9t SPI device (slave device) \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i v\u1edbi SPI controller th\u00f4ng qua m\u1ed9t bus v\u1eadt l\u00fd (c\u00e1c t\u00edn hi\u1ec7u c\u1ee7a SPI bus m\u00f4 t\u1ea3 \u1edf ph\u1ea7n tr\u01b0\u1edbc \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf tr\u00ean m\u1ea1ch c\u1ee9ng). M\u1ed9t SPI device \u0111\u01b0\u1ee3c \u0111\u1eb7c m\u00f4 t\u1ea3 b\u1edfi struct spi_device . V\u1ec1 ph\u1ea7n m\u1ec1m, hai th\u1ef1c th\u1ec3 ph\u1ea7n c\u1ee9ng tr\u00ean c\u1ea7n driver \u0111\u1ec3 giao ti\u1ebfp v\u00e0 qu\u1ea3n l\u00fd, driver cho controller ( controller driver ) v\u00e0 driver cho spi device ( protocol driver - this deffinition is used in Linux Kernel official document). Linux Kernel provides a sub-system to manage these device drivers, called SPI-core. All controller driver protocol driver have to register to Spi-core. C\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1eb7c quan tr\u1ecdng nh\u1ea5t cho m\u1ed9t controller l\u00e0 struct spi_master Figure 1. Components in SPI Subsystem SPI Message Transfer Th\u00f4ng tin trao \u0111\u1ed5i gi\u1eefa controller v\u00e0 device \u0111\u01b0\u1ee3c kh\u00e1i qu\u00e1t h\u00f3a trong Linux SPI subsystem th\u00e0nh d\u1ea1ng c\u00e1c message. C\u00e1c message n\u00e0y \u0111\u01b0\u1ee3c chia nh\u1ecf th\u00e0nh c\u00e1c transfer. Linux cung c\u1ea5p struct spi_message v\u00e0 struct spi_transfer \u0111\u1ec3 m\u00f4 t\u1ea3 c\u00e1c \u0111\u1ed1i t\u01b0\u1ee3ng n\u00e0y. C\u00e1c struct n\u00e0y \u0111\u1ec1u \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong spi.h. Figure. SPI msg has a list of SPI transfer spi_message ch\u1ee9a m\u1ed9t danh s\u00e1ch c\u00e1c transfer: struct spi_message { struct list_head transfers; ... } Qu\u00e1 tr\u00ecnh duy\u1ec7t to\u00e0n b\u1ed9 transfers trong list c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n nh\u01b0 sau: list_for_each_entry(xfer, msg- transfers, transfer_list) { ... } this function is used in spi_transfer_one_message() - a default implementation of transfer_one_message() in spi.c. See in Kernel Data Structure for more information about Linked List in device driver development. For Engineer So, what is mission for engineer in a SPI system? Ph\u00e1t tri\u1ec3n protocol driver: c\u00e1c \u1ee9ng d\u1ee5ng tr\u00ean t\u1ea7ng \u1ee9ng d\u1ee5ng c\u1ea7n truy c\u1eadp \u0111\u1ebfn th\u00f4ng tin tr\u00ean c\u00e1c SPI Device (v\u00ed d\u1ee5 nh\u01b0 \u0111\u1ecdc gi\u00e1 tr\u1ecb nhi\u1ec7t \u0111\u1ed9 t\u1eeb m\u1ed9t c\u1ea3m bi\u1ebfn, c\u1ea5u h\u00ecnh t\u00edn hi\u1ec7u clock cho m\u1ed9t h\u1ec7 th\u1ed1ng...). Do \u0111\u00f3 nhi\u1ec7m v\u1ee5 \u0111\u1ea7u ti\u00ean c\u1ee7a m\u1ed9t k\u1ef9 s\u01b0 l\u00e0 ph\u00e1t tri\u1ec3n Protocol Driver \u0111\u1ec3 cung c\u1ea5p c\u00e1c API giao ti\u1ebfp \u0111\u1ec3 \u1ee9ng d\u1ee5ng c\u00f3 th\u1ec3 truy c\u1eadp \u0111\u1ebfn ph\u1ea7n c\u1ee9ng ch\u1ee9a giao di\u1ec7n SPI. Ph\u00e1t tri\u1ec3n controller driver: th\u00f4ng th\u01b0\u1eddng driver c\u1ee7a controller th\u01b0\u1eddng \u0111\u01b0\u1ee3c c\u00e1c nh\u00e0 ph\u00e1t tri\u1ec3n t\u00edch h\u1ee3p k\u00e8m v\u1edbi controller. Nhi\u1ec7m v\u1ee5 c\u1ee7a k\u1ef9 s\u01b0 trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p l\u00e0 ti\u1ebfn h\u00e0nh thay \u0111\u1ed5i controller driver n\u00e0y cho ph\u00f9 h\u1ee3p v\u1edbi h\u1ec7 th\u1ed1ng hi\u1ec7n t\u1ea1i. Ngo\u00e0i ra, k\u1ef9 s\u01b0 c\u00f3 th\u1ec3 ph\u00e1t tri\u1ec3n th\u00eam c\u00e1c controller driver \u0111\u1ec3 ph\u00f9 h\u1ee3p v\u1edbi y\u00eau c\u1ea7u c\u1ee7a h\u1ec7 th\u1ed1ng. B\u1ed5 sung th\u00eam m\u1ed9t s\u1ed1 ch\u1ee9c n\u0103ng cho SPI-Core: giao di\u1ec7n SPI v\u1edbi c\u00e1c t\u00edn hi\u1ec7u nh\u01b0 m\u1ee5c gi\u1edbi thi\u1ec7u l\u00e0 giao di\u1ec7n chu\u1ea9n, trong khi c\u00e1c bi\u1ebfn t\u1ea5u c\u1ee7a giao di\u1ec7n SPI trong th\u1ef1c t\u1ebf l\u00e0 r\u1ea5t nhi\u1ec1u. Nh\u1eefng bi\u1ebfn t\u1ea5u n\u00e0y y\u00eau c\u1ea7u k\u1ef9 s\u01b0 ph\u1ea3i hi\u1ec3u s\u00e2u v\u1ec1 SPI-Core \u0111\u1ec3 trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p c\u00f3 th\u1ec3 b\u1ed5 sung th\u00eam m\u1ed9t s\u1ed1 API. V\u1ec1 t\u01b0 t\u01b0\u1edfng ph\u00e1t tri\u1ec3n, qu\u00e1 tr\u00ecnh vi\u1ebft m\u1ed9t driver ph\u1ea3i \u0111\u1ed9c l\u1eadp v\u1edbi Linux kernel, do \u0111\u00f3 ho\u1ea1t \u0111\u1ed9ng thay \u0111\u1ed5i v\u00e0 b\u1ed5 sung v\u00e0o SPI-Core n\u00e0y n\u00ean h\u1ea1n ch\u1ebf v\u00ec r\u00f5 r\u00e0ng can thi\u1ec7p v\u00e0o SPI-Core t\u1ee9c l\u00e0 \u00edt nhi\u1ec1u can thi\u1ec7p v\u00e0o Linux Kernel. Protocol Driver C\u00e1c ph\u1ea7n kh\u00e1c c\u1ee7a h\u1ec7 th\u1ed1ng (v\u00ed d\u1ee5 nh\u01b0 c\u00e1c \u1ee9ng d\u1ee5ng tr\u00ean user space, c\u00e1c kernel module kh\u00e1c) s\u1eed d\u1ee5ng c\u00e1c API c\u1ee7a Protocol Driver \u0111\u1ec3 c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi SPI Device. T\u01b0\u1ee3ng t\u1ef1 nh\u01b0 controller driver v\u00e0 platform device driver, spi protocol driver c\u0169ng c\u1ea7n ch\u1ee9a c\u00e1c th\u1ee7 t\u1ee5c c\u01a1 b\u1ea3n c\u1ee7a m\u1ed9t device driver. Khai b\u00e1o spi driver struct spi_driver v\u00e0 \u0111\u0103ng k\u00fd v\u1edbi kernel b\u1eb1ng macro module_spi_driver() . Struct driver n\u00e0y ch\u1ee9a c\u00e1c con tr\u1ecf ch\u1ec9 \u0111\u1ebfn c\u00e1c h\u00e0m kh\u1edfi tao (probe) v\u00e0 h\u00e0m h\u1ee7y (remove) c\u1ee7a driver, c\u00e1c h\u00e0m n\u00e0y sau khi \u0111\u01b0\u1ee3c \u0111\u0103ng k\u00fd s\u1ebd \u0111\u01b0\u1ee3c g\u1ecdi b\u1edfi Kernel. Khai b\u00e1o id_table struct spi_device_id ch\u1ee9a th\u00f4ng tin c\u1ee7a c\u00e1c device m\u00e0 driver n\u00e0y h\u1ed7 tr\u1ee3. Probing H\u00e0m probing c\u1ee7a Protocol Driver c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n ch\u1ee9c n\u0103ng nh\u01b0: L\u1ea5y th\u00f4ng tin c\u1ee7a struct spi_device *spi l\u01b0u tr\u1eef n\u1ed9i b\u1ed9 c\u1ee7a module \u0111\u1ec3 s\u1eed d\u1ee5ng cho c\u00e1c API kh\u00e1c. Th\u1ef1c hi\u1ec7n c\u1ea5u h\u00ecnh ban \u0111\u1ea7u cho spi device. C\u00e1c API kh\u00e1c Gi\u1ed1ng nh\u01b0 c\u00e1c Device Driver kh\u00e1c, protocol driver c\u00f3 ch\u1ee9a c\u00e1c API cung c\u1ea5p c\u00e1c c\u1ed5ng giao ti\u1ebfp v\u1edbi User Space th\u00f4ng quan Device File (/dev/), procfs, sysfs. Th\u00f4ng qua c\u00e1c system call nh\u01b0 IOCTL, read, write..., c\u00e1c \u1ee9ng d\u1ee5ng user space c\u00f3 th\u1ec3 truy c\u1eadp \u0111\u1ebfn thi\u1ebft b\u1ecb. V\u1ea5n \u0111\u1ec1 \u0111\u1eb7t ra l\u00e0 l\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 Protocol Driver c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c \u0111\u1ebfn Spi device? SPI-Write SPI-Read Protocol uses APIs from SPI-core to communicate with SPI device. These APIs are: int spi_write(struct spi_device *spi, const void *buf, size_t len) Take buffer (with length) as a pointer and then initialize a spi message. This message will be sent to slave device through spi controller (this procedure will be discussed detail in next part). In example below, spi_write is used in a function for writing a value to a register (specified by address) in device. An message with header (0x80), register address (addr) and expected value (val) will be sent to device. int xxx_write(struct spi_device *spi, unsigned addr, unsigned val) { unsigned char txbuf[3]; int rc; txbuf[0] = 0x00; txbuf[1] = addr 0xFF; txbuf[2] = val; rc = spi_write(spi, txbuf, 3); return rc; } int spi_write_then_read(struct spi_device *spi, const void *txbuf, unsigned n_tx, void *rxbuf, unsigned n_rx) API n\u00e0y th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u1ecdc thanh ghi c\u1ee7a m\u1ed9t thi\u1ebft b\u1ecb. M\u1ed9t b\u1ea3n tin t\u1eeb controller \u0111\u01b0\u1ee3c g\u1eedi cho device v\u1ec1 y\u00eau c\u1ea7u \u0111\u1ecdc thanh ghi, device ph\u1ea3n h\u1ed3i th\u00f4ng tin cho controller v\u00e0 tr\u1ea3 l\u1ea1i k\u1ebft qu\u1ea3 cho protocl driver. Trong v\u00ed d\u1ee5 sau, user buffer c\u00f3 k\u00edch th\u01b0\u1edbc 3 bytes \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng nh\u01b0 tx_buf v\u00e0 rx_buf (2 bytes \u0111\u1ea7u ti\u00ean \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho tx, 1 byte ti\u1ebfp theo s\u1eed d\u1ee5ng cho rx). Message buf[0:1] \u0111\u01b0\u1ee3c g\u1eedi \u0111i \u0111\u1ebfn device, k\u1ebft qu\u1ea3 tr\u1ea3 l\u1ea1i c\u1ee7a device \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong buf[2]. int xxx_read(struct spi_device *spi, unsigned addr) { unsigned char buf[3]; int rc; buf[0] = 0x80; buf[1] = addr 0xFF; buf[2] = 0x00; rc = spi_write_then_read(spi, buf, 2, buf[2],1); return (rc 0 ? rc : buf[2]); } B\u1ea3n ch\u1ea5t ho\u1ea1t \u0111\u1ed9ng c\u1ee7a c\u00e1c API tr\u00ean s\u1ebd \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 \u1edf trong ph\u1ea7n cu\u1ed1i c\u1ee7a t\u00e0i li\u1ec7u n\u00e0y. Controller Driver L\u00e0 kernel module giao ti\u1ebfp tr\u1ef1c ti\u1ebfp v\u1edbi SPI Controller. SPI controller n\u00e0y c\u00f3 th\u1ec3 l\u00e0 Hard-controller (nh\u01b0 controller c\u1ee7a Cadence \u0111\u01b0\u1ee3c t\u00edch h\u1ee3p s\u1eb5n trong ngo\u1ea1i vi c\u1ee7a SoC) ho\u1eb7c c\u0169ng c\u00f3 th\u1ec3 l\u00e0 Soft-controller nh\u01b0 SPI-GPIO (Bitbanging). Probing controller Initialize a spi master M\u1ed9t controller s\u1ebd \u0111\u01b0\u1ee3c \u0111\u1eb7c tr\u01b0ng b\u1edfi ki\u1ec3u d\u1eef li\u1ec7u: struct spi_master (\u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong: linux/include/spi/spi.h). Qu\u00e1 tr\u00ecnh khai b\u00e1o controller \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n trong h\u00e0m probe. struct spi_master *master; /*Allocate spi master*/ master = spi_alloc_master( spi- dev, sizeof(*spi_ad9250)); if (!master) return -ENOMEM; Set spi master to spi private private data Th\u00f4ng th\u01b0\u1eddng, con tr\u1ecf ch\u1ee9a \u0111\u1ecba ch\u1ec9 c\u1ee7a spi_master s\u1ebd \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong c\u00e1c private data c\u1ee7a device \u0111\u1ec3 thu\u1eadn ti\u1ec7n cho qu\u00e1 tr\u00ecnh s\u1eed d\u1ee5ng sau n\u00e0y. C\u1ee5 th\u1ec3 c\u00e1c API \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 l\u01b0u tr\u1eef master v\u00e0o drvdata nh\u01b0 sau: N\u1ebfu controller l\u00e0 m\u1ed9t platform device pdev : platform_set_drvdata(pdev, master); N\u1ebfu controller l\u00e0 m\u1ed9t spi device spi : spi_set_drvdata(spi, master) Register spi master ret = spi_register_master(master); if (ret) { dev_err( pdev- dev, spi_register_master failed\\n ); return -1; } Unregister spi master V\u00ed d\u1ee5 \u0111\u1ed1i v\u1edbi tr\u01b0\u1eddng h\u1ee3p controller l\u00e0 spi device: struct spi_master *master = spi_get_drvdata(spi); spi_unregister_master(master); Declare devices in Device Tree Qu\u00e1 tr\u00ecnh khai b\u00e1o m\u1ed9t thi\u1ebft b\u1ecb trong device tree c\u1ea7n l\u01b0u \u00fd \u0111\u1ebfn: thu\u1ed9c t\u00ednh num-cs c\u1ee7m father-node Thu\u1ed9c t\u00ednh spi-max-frequency c\u1ee7a node (why???) spi@e0006000 { compatible = xlnx,zynq-spi-r1p6 ; reg = 0xe0006000 0x1000 ; status = okay ; interrupt-parent = 0x1 ; interrupts = 0x0 0x1a 0x4 ; clocks = 0x2 0x19 0x2 0x22 ; clock-names = ref_clk , pclk ; #address-cells = 0x1 ; #size-cells = 0x0 ; spi-fmcjesdadc1@0 { #address-cells = 0x1 ; #size-cells = 0x0 ; compatible = spi-ad9250 ; reg = 0x0 ; spi-max-frequency = 0x989680 ; ad9517@1 { #clock-cells = 0x1 ; compatible = ad9517-1 ; reg = 0x1 ; spi-max-frequency = 0x989680 ; adi,spi-3wire-enable; clocks = 0x4 0x5 ; clock-names = refclk , clkin ; clock-output-names = out0 , out1 , out2 , out3 , out4 , out5 , out6 , out7 ; linux,phandle = 0x15 ; phandle = 0x15 ; }; ad9250-0@0 { compatible = ad9250 ; reg = 0x2 ; spi-max-frequency = 0x989680 ; clocks = 0x6 ; clock-names = adc_clk ; linux,phandle = 0x11 ; phandle = 0x11 ; }; Struct spi_master V\u1edbi t\u1ea5t c\u1ea3 c\u00e1c spi controller, spi controller driver c\u1ea7n c\u00f3 c\u00e1c h\u00e0m th\u1ee7 t\u1ee5c \u0111\u1ec3 c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi c\u00e1c controller t\u01b0\u01a1ng \u1ee9ng. C\u00e1c h\u00e0m v\u00e0 th\u1ee7 t\u1ee5c n\u00e0y \u0111\u01b0\u1ee3c chu\u1ea9n h\u00f3a v\u00e0 kh\u00e1i qu\u00e1t h\u00f3a th\u00e0nh m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u: struct spi_master. Struct spi_master \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong spi.h . About struct spi_master transfer_one_message : transfer a single message. SPI GPIO (bitbanging) uses this method. transfer_one : transfer a single spi_transfer. SPI Cadence controller uses this method. Register devices from device \u0110\u0103ng k\u00fd c\u00e1c thi\u1ebft b\u1ecb thu\u1ed9c bus SPI m\u00e0 spi master \u0111ang qu\u1ea3n l\u00fd b\u1eb1ng API: static void of_register_spi_devices(struct spi_master *master); API n\u00e0y s\u1ebd duy\u1ec7t h\u1ebft t\u1ea5t c\u1ea3 c\u00e1c child-node xu\u1ea5t hi\u1ec7n tr\u00ean Device Tree v\u00e0 ti\u1ebfn h\u00e0nh th\u00eam thi\u1ebft b\u1ecb \u0111\u00f3 v\u00e0o h\u1ec7 th\u1ed1ng b\u1eb1ng API: spi_add_device Controller Driver, Protocol Driver SPI-Core M\u1ee5c n\u00e0y m\u00f4 t\u1ea3 qu\u00e1 tr\u00ecnh Protocol Driver th\u00f4ng qua c\u00e1c API \u0111\u1ec3 s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean c\u1ee7a Controller Driver. spi_write/spi_read C\u00e1c protocol driver g\u1ecdi \u0111\u1ebfn c\u00e1c API nh\u01b0 spi_write/spi_read/spi_write_then_read , b\u1ea3n ch\u1ea5t trong c\u00e1c API n\u00e0y s\u1ebd th\u1ef1c hi\u1ec7n c\u00e1c b\u01b0\u1edbc sau: Khai b\u00e1o v\u00e0 c\u1ea5p ph\u00e1t struct spi_transfer v\u00e0 struct spi_message struct spi_transfer t = { .tx_buf = buf, .len = len, }; struct spi_message m; spi_message_init( m); spi_message_add_tail( t, m); G\u1ecdi \u0111\u1ebfn spi_sync - blocking/synchronous SPI data transfers. spi_sync s\u1ebd g\u1ecdi \u0111\u1ebfn con tr\u1ecf h\u00e0m master- transfer , m\u1ed9t ph\u01b0\u01a1ng th\u1ee9c cung c\u1ea5p b\u1edfi spi_master . master- transfer(spi, message); master- transfer \u0110a ph\u1ea7n trong c\u00e1c tr\u01b0\u1eddng h\u1ee3p, controller trong m\u1ed9t l\u00fac s\u1ebd nh\u1eadn \u0111\u01b0\u1ee3c r\u1ea5t nhi\u1ec1u y\u00eau c\u1ea7u trao \u0111\u1ed5i th\u00f4ng tin v\u1edbi c\u00e1c device. Do \u0111\u00f3, \u0111\u1ec3 tr\u00e1nh qu\u00e1 tr\u00ecnh xung \u0111\u1ed9t trong chia s\u1ebb t\u00e0i nguy\u00ean li\u00ean quan \u0111\u1ebfn controller, SPI-core s\u1eed d\u1ee5ng m\u00f4 h\u00ecnh h\u00e0ng \u0111\u1ee3i cho c\u00e1c y\u00eau c\u1ea7u. master- transfer l\u00e0m vi\u1ec7c nh\u01b0 th\u1ebf n\u00e0o trong SPI subsytem? Trong qu\u00e1 tr\u00ecnh \u0111\u0103ng k\u00fd spi_master cho controller driver, API spi_register_master kh\u1edfi t\u1ea1o m\u1ed9t h\u00e0ng \u0111\u1ee3i cho spi_master b\u1eb1ng API spi_master_initialize_queue (h\u00e0m n\u00e0y s\u1ebd g\u1ecdi \u0111\u1ebfn spi_init_queue ). spi_init_queue n\u00e0y s\u1ebd th\u1ef1c hi\u1ec7n kh\u1edfi t\u1ea1o m\u1ed9t kernel thread b\u1eb1ng kthread_run . SPI-core s\u1eed d\u1ee5ng kh\u00e1i ni\u1ec7m kworker v\u00e0 kwork \u0111\u1ec3 x\u1eed l\u00fd c\u00e1c master- transfer . master- transfer v\u00e0 kworker/kwork V\u1ec1 t\u01b0 t\u01b0\u1edfng kworker/kwork trong Linux Kernel, m\u1ed9t kworker \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t t\u00e0i nguy\u00ean (CPU) s\u1ebd \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec1 ho\u00e0n th\u00e0nh c\u00e1c kwork . Trong SPI-subsystem c\u0169ng ho\u1ea1t \u0111\u1ed9ng v\u1edbi c\u01a1 ch\u1ebf t\u01b0\u01a1ng t\u1ef1, m\u1ed7i master \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o m\u1ed9t struct kthread_worker kworker b\u1eb1ng API init_kthread_worker trong spi_init_queue . spi_init_queue \u0111\u1ed3ng th\u1eddi kh\u1edfi t\u1ea1o m\u1ed9t kernel thread d\u00e0nh ri\u00eang \u0111\u1ec3 th\u1ef1c hi\u1ec7n kthread_worker n\u00e0y. \u0110\u1ed1i v\u1edbi Cadence Controller, h\u00e0m master- transfer \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a b\u1eb1ng spi_queued_transfer trong SPI core. Qu\u00e1 tr\u00ecnh th\u1ef1c hi\u1ec7n c\u1ee7a spi_queued_transfer b\u1ea3n ch\u1ea5t l\u00e0 \u0111\u01b0a spi_message v\u00e0o work queue \u0111\u1ec3 ch\u1edd kwork x\u1eed l\u00fd. Nh\u01b0 v\u1eady, c\u00e1c request message t\u1eeb protocol driver \u0111\u01b0\u1ee3c x\u1ebfp th\u00e0nh h\u00e0ng \u0111\u1ec3 kworker/kwork x\u1eed l\u00fd. B\u1ea3n ch\u1ea5t kwork- fn tr\u1ecf \u0111\u1ebfn spi_pump_messages . spi_pump_messages Th\u1ef1c hi\u1ec7n \"b\u01a1m\" b\u1ea3n tin v\u00e0o SPI bus b\u1eb1ng c\u00e1c g\u1ecdi \u0111\u1ebfn master- transfer_one_message master- transfer_one_message transfer_one_message c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong controller driver. Trong tr\u01b0\u1eddng h\u1ee3p kh\u00f4ng \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong qu\u00e1 tr\u00ecnh khai b\u00e1o spi_master c\u1ee7a controller driver, transfer_one_message \u0111\u01b0\u1ee3c tr\u1ecf \u0111\u1ebfn h\u00e0m spi_transfer_one_massge \u0111\u1ecbnh ngh\u0129a trong SPI core. What's next? spi_master c\u00f3 th\u1ec3 c\u1ea7n cung c\u1ea5p h\u00e0m cho c\u00e1c ph\u01b0\u01a1ng th\u1ee9c nh\u01b0: transfer_one_message , transfer_one . V\u1eady kh\u00e1c nhau gi\u1eefa hai ph\u01b0\u01a1ng th\u1ee9c n\u00e0y l\u00e0 g\u00ec? M\u00f4 t\u1ea3 c\u00e1c tr\u01b0\u1eddng h\u1ee3p thi\u1ebft k\u1ebf SPI bus trong th\u1ef1c t\u1ebf. Refereneces Groking the Linux SPI Subsystem - Embedded Linux Conference 2017 spi/spi-summary - Linux Kernel Document ( link ) The Linux Kernel - SPI","title":"SPI Device"},{"location":"ldd/spi_dev/spi_dev/#spi-device-driver","text":"Hanoi - Tuesday, January 29, 2019 - by VuTang","title":"SPI Device Driver"},{"location":"ldd/spi_dev/spi_dev/#introduction","text":"SPI l\u00e0 chu\u1ea9n giao ti\u1ebfp n\u1ed1i ti\u1ebfp d\u1ef1a tr\u00ean m\u00f4 h\u00ecnh Master-Slaves, trong \u0111\u00f3 m\u1ed9t master c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i \u0111\u1ebfn m\u1ed9t ho\u1eb7c nhi\u1ec1u thi\u1ebft b\u1ecb slave. M\u1ed9t bus SPI th\u00f4ng th\u01b0\u1eddng c\u00f3 4 t\u00edn hi\u1ec7u: SCLK: clock d\u00f9ng cho \u0111\u1ed3ng b\u1ed9 t\u00edn hi\u1ec7u SS: Slave Select, d\u00f9ng \u0111\u1ec3 \u0111\u00e1nh d\u1ea5u thi\u1ebft b\u1ecb Slave n\u00e0o \u0111\u01b0\u1ee3c active \u0111\u1ec3 trao \u0111\u1ed5i d\u1eef li\u1ec7u. Pin n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c g\u1ecdi b\u1eb1ng c\u00e1c t\u00ean kh\u00e1c nh\u01b0: CS (chip sellect), LE (Latch Enable), \u2026 T\u00edn hi\u1ec7u SS th\u00f4ng th\u01b0\u1eddng active m\u1ee9c th\u1ea5p. MISO: d\u1eef li\u1ec7u v\u00e0o c\u1ee7a master MOSI: d\u1eef li\u1ec7u ra c\u1ee7a master. Trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p, pin MISO/MOSI c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng chung tr\u00ean m\u1ed9t \u0111\u01b0\u1eddng t\u00edn hi\u1ec7u \u0111\u1ea3m nhi\u1ec7m c\u1ea3 hai ch\u1ee9c n\u0103ng in/out. Figure. SPI bus signals","title":"Introduction"},{"location":"ldd/spi_dev/spi_dev/#spi-subsystem-in-linux","text":"C\u00e1c ki\u1ebfn th\u1ee9c trong technote n\u00e0y \u0111\u01b0\u1ee3c kh\u00e1i qu\u00e1t h\u00f3a sau qu\u00e1 tr\u00ecnh t\u00ecm hi\u1ec3u h\u1ec7 th\u1ed1ng SPI s\u1eed d\u1ee5ng Cadence Controller v\u00e0 SPI-GPIO, do \u0111\u00f3 c\u00f3 th\u1ec3 kh\u00f4ng mang \u0111\u01b0\u1ee3c t\u00ednh t\u1ed5ng qu\u00e1t h\u00f3a l\u00ean to\u00e0n b\u1ed9 c\u00e1c thi\u1ebft b\u1ecb SPI. spi.h : defines important data structures what are used for SPI subsystem. spi.c : SPI core APIs are implemented in this file.","title":"SPI Subsystem in Linux"},{"location":"ldd/spi_dev/spi_dev/#spi-device-driver-model","text":"Trong Figure 1 th\u1ec3 hi\u1ec7n m\u00f4 h\u00ecnh c\u1ee7a m\u1ed9t h\u1ec7 th\u1ed1ng SPI trong Linux, bao g\u1ed3m: V\u1ec1 ph\u1ea7n c\u1ee9ng, m\u1ed9t SPI device (slave device) \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i v\u1edbi SPI controller th\u00f4ng qua m\u1ed9t bus v\u1eadt l\u00fd (c\u00e1c t\u00edn hi\u1ec7u c\u1ee7a SPI bus m\u00f4 t\u1ea3 \u1edf ph\u1ea7n tr\u01b0\u1edbc \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf tr\u00ean m\u1ea1ch c\u1ee9ng). M\u1ed9t SPI device \u0111\u01b0\u1ee3c \u0111\u1eb7c m\u00f4 t\u1ea3 b\u1edfi struct spi_device . V\u1ec1 ph\u1ea7n m\u1ec1m, hai th\u1ef1c th\u1ec3 ph\u1ea7n c\u1ee9ng tr\u00ean c\u1ea7n driver \u0111\u1ec3 giao ti\u1ebfp v\u00e0 qu\u1ea3n l\u00fd, driver cho controller ( controller driver ) v\u00e0 driver cho spi device ( protocol driver - this deffinition is used in Linux Kernel official document). Linux Kernel provides a sub-system to manage these device drivers, called SPI-core. All controller driver protocol driver have to register to Spi-core. C\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1eb7c quan tr\u1ecdng nh\u1ea5t cho m\u1ed9t controller l\u00e0 struct spi_master Figure 1. Components in SPI Subsystem","title":"SPI Device Driver Model"},{"location":"ldd/spi_dev/spi_dev/#spi-message-transfer","text":"Th\u00f4ng tin trao \u0111\u1ed5i gi\u1eefa controller v\u00e0 device \u0111\u01b0\u1ee3c kh\u00e1i qu\u00e1t h\u00f3a trong Linux SPI subsystem th\u00e0nh d\u1ea1ng c\u00e1c message. C\u00e1c message n\u00e0y \u0111\u01b0\u1ee3c chia nh\u1ecf th\u00e0nh c\u00e1c transfer. Linux cung c\u1ea5p struct spi_message v\u00e0 struct spi_transfer \u0111\u1ec3 m\u00f4 t\u1ea3 c\u00e1c \u0111\u1ed1i t\u01b0\u1ee3ng n\u00e0y. C\u00e1c struct n\u00e0y \u0111\u1ec1u \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong spi.h. Figure. SPI msg has a list of SPI transfer spi_message ch\u1ee9a m\u1ed9t danh s\u00e1ch c\u00e1c transfer: struct spi_message { struct list_head transfers; ... } Qu\u00e1 tr\u00ecnh duy\u1ec7t to\u00e0n b\u1ed9 transfers trong list c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n nh\u01b0 sau: list_for_each_entry(xfer, msg- transfers, transfer_list) { ... } this function is used in spi_transfer_one_message() - a default implementation of transfer_one_message() in spi.c. See in Kernel Data Structure for more information about Linked List in device driver development.","title":"SPI Message &amp; Transfer"},{"location":"ldd/spi_dev/spi_dev/#for-engineer","text":"So, what is mission for engineer in a SPI system? Ph\u00e1t tri\u1ec3n protocol driver: c\u00e1c \u1ee9ng d\u1ee5ng tr\u00ean t\u1ea7ng \u1ee9ng d\u1ee5ng c\u1ea7n truy c\u1eadp \u0111\u1ebfn th\u00f4ng tin tr\u00ean c\u00e1c SPI Device (v\u00ed d\u1ee5 nh\u01b0 \u0111\u1ecdc gi\u00e1 tr\u1ecb nhi\u1ec7t \u0111\u1ed9 t\u1eeb m\u1ed9t c\u1ea3m bi\u1ebfn, c\u1ea5u h\u00ecnh t\u00edn hi\u1ec7u clock cho m\u1ed9t h\u1ec7 th\u1ed1ng...). Do \u0111\u00f3 nhi\u1ec7m v\u1ee5 \u0111\u1ea7u ti\u00ean c\u1ee7a m\u1ed9t k\u1ef9 s\u01b0 l\u00e0 ph\u00e1t tri\u1ec3n Protocol Driver \u0111\u1ec3 cung c\u1ea5p c\u00e1c API giao ti\u1ebfp \u0111\u1ec3 \u1ee9ng d\u1ee5ng c\u00f3 th\u1ec3 truy c\u1eadp \u0111\u1ebfn ph\u1ea7n c\u1ee9ng ch\u1ee9a giao di\u1ec7n SPI. Ph\u00e1t tri\u1ec3n controller driver: th\u00f4ng th\u01b0\u1eddng driver c\u1ee7a controller th\u01b0\u1eddng \u0111\u01b0\u1ee3c c\u00e1c nh\u00e0 ph\u00e1t tri\u1ec3n t\u00edch h\u1ee3p k\u00e8m v\u1edbi controller. Nhi\u1ec7m v\u1ee5 c\u1ee7a k\u1ef9 s\u01b0 trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p l\u00e0 ti\u1ebfn h\u00e0nh thay \u0111\u1ed5i controller driver n\u00e0y cho ph\u00f9 h\u1ee3p v\u1edbi h\u1ec7 th\u1ed1ng hi\u1ec7n t\u1ea1i. Ngo\u00e0i ra, k\u1ef9 s\u01b0 c\u00f3 th\u1ec3 ph\u00e1t tri\u1ec3n th\u00eam c\u00e1c controller driver \u0111\u1ec3 ph\u00f9 h\u1ee3p v\u1edbi y\u00eau c\u1ea7u c\u1ee7a h\u1ec7 th\u1ed1ng. B\u1ed5 sung th\u00eam m\u1ed9t s\u1ed1 ch\u1ee9c n\u0103ng cho SPI-Core: giao di\u1ec7n SPI v\u1edbi c\u00e1c t\u00edn hi\u1ec7u nh\u01b0 m\u1ee5c gi\u1edbi thi\u1ec7u l\u00e0 giao di\u1ec7n chu\u1ea9n, trong khi c\u00e1c bi\u1ebfn t\u1ea5u c\u1ee7a giao di\u1ec7n SPI trong th\u1ef1c t\u1ebf l\u00e0 r\u1ea5t nhi\u1ec1u. Nh\u1eefng bi\u1ebfn t\u1ea5u n\u00e0y y\u00eau c\u1ea7u k\u1ef9 s\u01b0 ph\u1ea3i hi\u1ec3u s\u00e2u v\u1ec1 SPI-Core \u0111\u1ec3 trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p c\u00f3 th\u1ec3 b\u1ed5 sung th\u00eam m\u1ed9t s\u1ed1 API. V\u1ec1 t\u01b0 t\u01b0\u1edfng ph\u00e1t tri\u1ec3n, qu\u00e1 tr\u00ecnh vi\u1ebft m\u1ed9t driver ph\u1ea3i \u0111\u1ed9c l\u1eadp v\u1edbi Linux kernel, do \u0111\u00f3 ho\u1ea1t \u0111\u1ed9ng thay \u0111\u1ed5i v\u00e0 b\u1ed5 sung v\u00e0o SPI-Core n\u00e0y n\u00ean h\u1ea1n ch\u1ebf v\u00ec r\u00f5 r\u00e0ng can thi\u1ec7p v\u00e0o SPI-Core t\u1ee9c l\u00e0 \u00edt nhi\u1ec1u can thi\u1ec7p v\u00e0o Linux Kernel.","title":"For Engineer"},{"location":"ldd/spi_dev/spi_dev/#protocol-driver","text":"C\u00e1c ph\u1ea7n kh\u00e1c c\u1ee7a h\u1ec7 th\u1ed1ng (v\u00ed d\u1ee5 nh\u01b0 c\u00e1c \u1ee9ng d\u1ee5ng tr\u00ean user space, c\u00e1c kernel module kh\u00e1c) s\u1eed d\u1ee5ng c\u00e1c API c\u1ee7a Protocol Driver \u0111\u1ec3 c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi SPI Device. T\u01b0\u1ee3ng t\u1ef1 nh\u01b0 controller driver v\u00e0 platform device driver, spi protocol driver c\u0169ng c\u1ea7n ch\u1ee9a c\u00e1c th\u1ee7 t\u1ee5c c\u01a1 b\u1ea3n c\u1ee7a m\u1ed9t device driver. Khai b\u00e1o spi driver struct spi_driver v\u00e0 \u0111\u0103ng k\u00fd v\u1edbi kernel b\u1eb1ng macro module_spi_driver() . Struct driver n\u00e0y ch\u1ee9a c\u00e1c con tr\u1ecf ch\u1ec9 \u0111\u1ebfn c\u00e1c h\u00e0m kh\u1edfi tao (probe) v\u00e0 h\u00e0m h\u1ee7y (remove) c\u1ee7a driver, c\u00e1c h\u00e0m n\u00e0y sau khi \u0111\u01b0\u1ee3c \u0111\u0103ng k\u00fd s\u1ebd \u0111\u01b0\u1ee3c g\u1ecdi b\u1edfi Kernel. Khai b\u00e1o id_table struct spi_device_id ch\u1ee9a th\u00f4ng tin c\u1ee7a c\u00e1c device m\u00e0 driver n\u00e0y h\u1ed7 tr\u1ee3.","title":"Protocol Driver"},{"location":"ldd/spi_dev/spi_dev/#probing","text":"H\u00e0m probing c\u1ee7a Protocol Driver c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n ch\u1ee9c n\u0103ng nh\u01b0: L\u1ea5y th\u00f4ng tin c\u1ee7a struct spi_device *spi l\u01b0u tr\u1eef n\u1ed9i b\u1ed9 c\u1ee7a module \u0111\u1ec3 s\u1eed d\u1ee5ng cho c\u00e1c API kh\u00e1c. Th\u1ef1c hi\u1ec7n c\u1ea5u h\u00ecnh ban \u0111\u1ea7u cho spi device.","title":"Probing"},{"location":"ldd/spi_dev/spi_dev/#cac-api-khac","text":"Gi\u1ed1ng nh\u01b0 c\u00e1c Device Driver kh\u00e1c, protocol driver c\u00f3 ch\u1ee9a c\u00e1c API cung c\u1ea5p c\u00e1c c\u1ed5ng giao ti\u1ebfp v\u1edbi User Space th\u00f4ng quan Device File (/dev/), procfs, sysfs. Th\u00f4ng qua c\u00e1c system call nh\u01b0 IOCTL, read, write..., c\u00e1c \u1ee9ng d\u1ee5ng user space c\u00f3 th\u1ec3 truy c\u1eadp \u0111\u1ebfn thi\u1ebft b\u1ecb. V\u1ea5n \u0111\u1ec1 \u0111\u1eb7t ra l\u00e0 l\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 Protocol Driver c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c \u0111\u1ebfn Spi device?","title":"C\u00e1c API kh\u00e1c"},{"location":"ldd/spi_dev/spi_dev/#spi-write-spi-read","text":"Protocol uses APIs from SPI-core to communicate with SPI device. These APIs are: int spi_write(struct spi_device *spi, const void *buf, size_t len) Take buffer (with length) as a pointer and then initialize a spi message. This message will be sent to slave device through spi controller (this procedure will be discussed detail in next part). In example below, spi_write is used in a function for writing a value to a register (specified by address) in device. An message with header (0x80), register address (addr) and expected value (val) will be sent to device. int xxx_write(struct spi_device *spi, unsigned addr, unsigned val) { unsigned char txbuf[3]; int rc; txbuf[0] = 0x00; txbuf[1] = addr 0xFF; txbuf[2] = val; rc = spi_write(spi, txbuf, 3); return rc; } int spi_write_then_read(struct spi_device *spi, const void *txbuf, unsigned n_tx, void *rxbuf, unsigned n_rx) API n\u00e0y th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111\u1ecdc thanh ghi c\u1ee7a m\u1ed9t thi\u1ebft b\u1ecb. M\u1ed9t b\u1ea3n tin t\u1eeb controller \u0111\u01b0\u1ee3c g\u1eedi cho device v\u1ec1 y\u00eau c\u1ea7u \u0111\u1ecdc thanh ghi, device ph\u1ea3n h\u1ed3i th\u00f4ng tin cho controller v\u00e0 tr\u1ea3 l\u1ea1i k\u1ebft qu\u1ea3 cho protocl driver. Trong v\u00ed d\u1ee5 sau, user buffer c\u00f3 k\u00edch th\u01b0\u1edbc 3 bytes \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng nh\u01b0 tx_buf v\u00e0 rx_buf (2 bytes \u0111\u1ea7u ti\u00ean \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho tx, 1 byte ti\u1ebfp theo s\u1eed d\u1ee5ng cho rx). Message buf[0:1] \u0111\u01b0\u1ee3c g\u1eedi \u0111i \u0111\u1ebfn device, k\u1ebft qu\u1ea3 tr\u1ea3 l\u1ea1i c\u1ee7a device \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong buf[2]. int xxx_read(struct spi_device *spi, unsigned addr) { unsigned char buf[3]; int rc; buf[0] = 0x80; buf[1] = addr 0xFF; buf[2] = 0x00; rc = spi_write_then_read(spi, buf, 2, buf[2],1); return (rc 0 ? rc : buf[2]); } B\u1ea3n ch\u1ea5t ho\u1ea1t \u0111\u1ed9ng c\u1ee7a c\u00e1c API tr\u00ean s\u1ebd \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 \u1edf trong ph\u1ea7n cu\u1ed1i c\u1ee7a t\u00e0i li\u1ec7u n\u00e0y.","title":"SPI-Write &amp; SPI-Read"},{"location":"ldd/spi_dev/spi_dev/#controller-driver","text":"L\u00e0 kernel module giao ti\u1ebfp tr\u1ef1c ti\u1ebfp v\u1edbi SPI Controller. SPI controller n\u00e0y c\u00f3 th\u1ec3 l\u00e0 Hard-controller (nh\u01b0 controller c\u1ee7a Cadence \u0111\u01b0\u1ee3c t\u00edch h\u1ee3p s\u1eb5n trong ngo\u1ea1i vi c\u1ee7a SoC) ho\u1eb7c c\u0169ng c\u00f3 th\u1ec3 l\u00e0 Soft-controller nh\u01b0 SPI-GPIO (Bitbanging).","title":"Controller Driver"},{"location":"ldd/spi_dev/spi_dev/#probing-controller","text":"Initialize a spi master M\u1ed9t controller s\u1ebd \u0111\u01b0\u1ee3c \u0111\u1eb7c tr\u01b0ng b\u1edfi ki\u1ec3u d\u1eef li\u1ec7u: struct spi_master (\u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong: linux/include/spi/spi.h). Qu\u00e1 tr\u00ecnh khai b\u00e1o controller \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n trong h\u00e0m probe. struct spi_master *master; /*Allocate spi master*/ master = spi_alloc_master( spi- dev, sizeof(*spi_ad9250)); if (!master) return -ENOMEM; Set spi master to spi private private data Th\u00f4ng th\u01b0\u1eddng, con tr\u1ecf ch\u1ee9a \u0111\u1ecba ch\u1ec9 c\u1ee7a spi_master s\u1ebd \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong c\u00e1c private data c\u1ee7a device \u0111\u1ec3 thu\u1eadn ti\u1ec7n cho qu\u00e1 tr\u00ecnh s\u1eed d\u1ee5ng sau n\u00e0y. C\u1ee5 th\u1ec3 c\u00e1c API \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 l\u01b0u tr\u1eef master v\u00e0o drvdata nh\u01b0 sau: N\u1ebfu controller l\u00e0 m\u1ed9t platform device pdev : platform_set_drvdata(pdev, master); N\u1ebfu controller l\u00e0 m\u1ed9t spi device spi : spi_set_drvdata(spi, master) Register spi master ret = spi_register_master(master); if (ret) { dev_err( pdev- dev, spi_register_master failed\\n ); return -1; } Unregister spi master V\u00ed d\u1ee5 \u0111\u1ed1i v\u1edbi tr\u01b0\u1eddng h\u1ee3p controller l\u00e0 spi device: struct spi_master *master = spi_get_drvdata(spi); spi_unregister_master(master); Declare devices in Device Tree Qu\u00e1 tr\u00ecnh khai b\u00e1o m\u1ed9t thi\u1ebft b\u1ecb trong device tree c\u1ea7n l\u01b0u \u00fd \u0111\u1ebfn: thu\u1ed9c t\u00ednh num-cs c\u1ee7m father-node Thu\u1ed9c t\u00ednh spi-max-frequency c\u1ee7a node (why???) spi@e0006000 { compatible = xlnx,zynq-spi-r1p6 ; reg = 0xe0006000 0x1000 ; status = okay ; interrupt-parent = 0x1 ; interrupts = 0x0 0x1a 0x4 ; clocks = 0x2 0x19 0x2 0x22 ; clock-names = ref_clk , pclk ; #address-cells = 0x1 ; #size-cells = 0x0 ; spi-fmcjesdadc1@0 { #address-cells = 0x1 ; #size-cells = 0x0 ; compatible = spi-ad9250 ; reg = 0x0 ; spi-max-frequency = 0x989680 ; ad9517@1 { #clock-cells = 0x1 ; compatible = ad9517-1 ; reg = 0x1 ; spi-max-frequency = 0x989680 ; adi,spi-3wire-enable; clocks = 0x4 0x5 ; clock-names = refclk , clkin ; clock-output-names = out0 , out1 , out2 , out3 , out4 , out5 , out6 , out7 ; linux,phandle = 0x15 ; phandle = 0x15 ; }; ad9250-0@0 { compatible = ad9250 ; reg = 0x2 ; spi-max-frequency = 0x989680 ; clocks = 0x6 ; clock-names = adc_clk ; linux,phandle = 0x11 ; phandle = 0x11 ; };","title":"Probing controller"},{"location":"ldd/spi_dev/spi_dev/#struct-spi_master","text":"V\u1edbi t\u1ea5t c\u1ea3 c\u00e1c spi controller, spi controller driver c\u1ea7n c\u00f3 c\u00e1c h\u00e0m th\u1ee7 t\u1ee5c \u0111\u1ec3 c\u00f3 th\u1ec3 giao ti\u1ebfp \u0111\u01b0\u1ee3c v\u1edbi c\u00e1c controller t\u01b0\u01a1ng \u1ee9ng. C\u00e1c h\u00e0m v\u00e0 th\u1ee7 t\u1ee5c n\u00e0y \u0111\u01b0\u1ee3c chu\u1ea9n h\u00f3a v\u00e0 kh\u00e1i qu\u00e1t h\u00f3a th\u00e0nh m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u: struct spi_master. Struct spi_master \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong spi.h . About struct spi_master transfer_one_message : transfer a single message. SPI GPIO (bitbanging) uses this method. transfer_one : transfer a single spi_transfer. SPI Cadence controller uses this method. Register devices from device \u0110\u0103ng k\u00fd c\u00e1c thi\u1ebft b\u1ecb thu\u1ed9c bus SPI m\u00e0 spi master \u0111ang qu\u1ea3n l\u00fd b\u1eb1ng API: static void of_register_spi_devices(struct spi_master *master); API n\u00e0y s\u1ebd duy\u1ec7t h\u1ebft t\u1ea5t c\u1ea3 c\u00e1c child-node xu\u1ea5t hi\u1ec7n tr\u00ean Device Tree v\u00e0 ti\u1ebfn h\u00e0nh th\u00eam thi\u1ebft b\u1ecb \u0111\u00f3 v\u00e0o h\u1ec7 th\u1ed1ng b\u1eb1ng API: spi_add_device","title":"Struct spi_master"},{"location":"ldd/spi_dev/spi_dev/#controller-driver-protocol-driver-spi-core","text":"M\u1ee5c n\u00e0y m\u00f4 t\u1ea3 qu\u00e1 tr\u00ecnh Protocol Driver th\u00f4ng qua c\u00e1c API \u0111\u1ec3 s\u1eed d\u1ee5ng c\u00e1c t\u00e0i nguy\u00ean c\u1ee7a Controller Driver.","title":"Controller Driver, Protocol Driver &amp; SPI-Core"},{"location":"ldd/spi_dev/spi_dev/#spi_writespi_read","text":"C\u00e1c protocol driver g\u1ecdi \u0111\u1ebfn c\u00e1c API nh\u01b0 spi_write/spi_read/spi_write_then_read , b\u1ea3n ch\u1ea5t trong c\u00e1c API n\u00e0y s\u1ebd th\u1ef1c hi\u1ec7n c\u00e1c b\u01b0\u1edbc sau: Khai b\u00e1o v\u00e0 c\u1ea5p ph\u00e1t struct spi_transfer v\u00e0 struct spi_message struct spi_transfer t = { .tx_buf = buf, .len = len, }; struct spi_message m; spi_message_init( m); spi_message_add_tail( t, m); G\u1ecdi \u0111\u1ebfn spi_sync - blocking/synchronous SPI data transfers. spi_sync s\u1ebd g\u1ecdi \u0111\u1ebfn con tr\u1ecf h\u00e0m master- transfer , m\u1ed9t ph\u01b0\u01a1ng th\u1ee9c cung c\u1ea5p b\u1edfi spi_master . master- transfer(spi, message);","title":"spi_write/spi_read"},{"location":"ldd/spi_dev/spi_dev/#master-transfer","text":"\u0110a ph\u1ea7n trong c\u00e1c tr\u01b0\u1eddng h\u1ee3p, controller trong m\u1ed9t l\u00fac s\u1ebd nh\u1eadn \u0111\u01b0\u1ee3c r\u1ea5t nhi\u1ec1u y\u00eau c\u1ea7u trao \u0111\u1ed5i th\u00f4ng tin v\u1edbi c\u00e1c device. Do \u0111\u00f3, \u0111\u1ec3 tr\u00e1nh qu\u00e1 tr\u00ecnh xung \u0111\u1ed9t trong chia s\u1ebb t\u00e0i nguy\u00ean li\u00ean quan \u0111\u1ebfn controller, SPI-core s\u1eed d\u1ee5ng m\u00f4 h\u00ecnh h\u00e0ng \u0111\u1ee3i cho c\u00e1c y\u00eau c\u1ea7u. master- transfer l\u00e0m vi\u1ec7c nh\u01b0 th\u1ebf n\u00e0o trong SPI subsytem? Trong qu\u00e1 tr\u00ecnh \u0111\u0103ng k\u00fd spi_master cho controller driver, API spi_register_master kh\u1edfi t\u1ea1o m\u1ed9t h\u00e0ng \u0111\u1ee3i cho spi_master b\u1eb1ng API spi_master_initialize_queue (h\u00e0m n\u00e0y s\u1ebd g\u1ecdi \u0111\u1ebfn spi_init_queue ). spi_init_queue n\u00e0y s\u1ebd th\u1ef1c hi\u1ec7n kh\u1edfi t\u1ea1o m\u1ed9t kernel thread b\u1eb1ng kthread_run . SPI-core s\u1eed d\u1ee5ng kh\u00e1i ni\u1ec7m kworker v\u00e0 kwork \u0111\u1ec3 x\u1eed l\u00fd c\u00e1c master- transfer . master- transfer v\u00e0 kworker/kwork V\u1ec1 t\u01b0 t\u01b0\u1edfng kworker/kwork trong Linux Kernel, m\u1ed9t kworker \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t t\u00e0i nguy\u00ean (CPU) s\u1ebd \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec1 ho\u00e0n th\u00e0nh c\u00e1c kwork . Trong SPI-subsystem c\u0169ng ho\u1ea1t \u0111\u1ed9ng v\u1edbi c\u01a1 ch\u1ebf t\u01b0\u01a1ng t\u1ef1, m\u1ed7i master \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o m\u1ed9t struct kthread_worker kworker b\u1eb1ng API init_kthread_worker trong spi_init_queue . spi_init_queue \u0111\u1ed3ng th\u1eddi kh\u1edfi t\u1ea1o m\u1ed9t kernel thread d\u00e0nh ri\u00eang \u0111\u1ec3 th\u1ef1c hi\u1ec7n kthread_worker n\u00e0y. \u0110\u1ed1i v\u1edbi Cadence Controller, h\u00e0m master- transfer \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a b\u1eb1ng spi_queued_transfer trong SPI core. Qu\u00e1 tr\u00ecnh th\u1ef1c hi\u1ec7n c\u1ee7a spi_queued_transfer b\u1ea3n ch\u1ea5t l\u00e0 \u0111\u01b0a spi_message v\u00e0o work queue \u0111\u1ec3 ch\u1edd kwork x\u1eed l\u00fd. Nh\u01b0 v\u1eady, c\u00e1c request message t\u1eeb protocol driver \u0111\u01b0\u1ee3c x\u1ebfp th\u00e0nh h\u00e0ng \u0111\u1ec3 kworker/kwork x\u1eed l\u00fd. B\u1ea3n ch\u1ea5t kwork- fn tr\u1ecf \u0111\u1ebfn spi_pump_messages . spi_pump_messages Th\u1ef1c hi\u1ec7n \"b\u01a1m\" b\u1ea3n tin v\u00e0o SPI bus b\u1eb1ng c\u00e1c g\u1ecdi \u0111\u1ebfn master- transfer_one_message master- transfer_one_message transfer_one_message c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong controller driver. Trong tr\u01b0\u1eddng h\u1ee3p kh\u00f4ng \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong qu\u00e1 tr\u00ecnh khai b\u00e1o spi_master c\u1ee7a controller driver, transfer_one_message \u0111\u01b0\u1ee3c tr\u1ecf \u0111\u1ebfn h\u00e0m spi_transfer_one_massge \u0111\u1ecbnh ngh\u0129a trong SPI core.","title":"master-&gt;transfer"},{"location":"ldd/spi_dev/spi_dev/#whats-next","text":"spi_master c\u00f3 th\u1ec3 c\u1ea7n cung c\u1ea5p h\u00e0m cho c\u00e1c ph\u01b0\u01a1ng th\u1ee9c nh\u01b0: transfer_one_message , transfer_one . V\u1eady kh\u00e1c nhau gi\u1eefa hai ph\u01b0\u01a1ng th\u1ee9c n\u00e0y l\u00e0 g\u00ec? M\u00f4 t\u1ea3 c\u00e1c tr\u01b0\u1eddng h\u1ee3p thi\u1ebft k\u1ebf SPI bus trong th\u1ef1c t\u1ebf.","title":"What's next?"},{"location":"ldd/spi_dev/spi_dev/#refereneces","text":"Groking the Linux SPI Subsystem - Embedded Linux Conference 2017 spi/spi-summary - Linux Kernel Document ( link ) The Linux Kernel - SPI","title":"Refereneces"},{"location":"ldd/uart/uart/","text":"UART: Serial programming Userspace Referring to: Serial Programming HOWTO (online article) - www.tpld.org Serial HOWTO - www.tpld.org Chapter 62 - Terminals - The Linux Programming Interface (book) Serial Programming Guide for POSIX Compliant Operating Systems (online article) - Michael R. Sweet for detail intructions when programing with serial port. A serial port configuration is stored in a structure struct termios , which defined in asm/termbits.h . Userspace program interfaces with serial port via device file ( /dev/ttyS0 for example). When a new session with a serial port is created, current configuration will be saved in struct termios oldtio , oldtio is get from device by API: int tcgetattr(int fd, struct termios *termios_p); A new configuration struct termios newtio is created and applied to device by API: int tcsetattr(int fd, int optional_actions, const struct termios *termios_p); After applying compatible configuration, userspace application can communicate with serial port by calling read and write system call with file description fd . Kernelspace Referring to: Linux serial drivers - bootlin.com - said about how to write an UART device driver. To be properly intergrated in a Linux system, serial ports like UART must be visible as TTY devices from user space application. Therefore, the serial driver must be part of the kernle TTY subsystem.","title":"UART"},{"location":"ldd/uart/uart/#uart-serial-programming","text":"","title":"UART: Serial programming"},{"location":"ldd/uart/uart/#userspace","text":"Referring to: Serial Programming HOWTO (online article) - www.tpld.org Serial HOWTO - www.tpld.org Chapter 62 - Terminals - The Linux Programming Interface (book) Serial Programming Guide for POSIX Compliant Operating Systems (online article) - Michael R. Sweet for detail intructions when programing with serial port. A serial port configuration is stored in a structure struct termios , which defined in asm/termbits.h . Userspace program interfaces with serial port via device file ( /dev/ttyS0 for example). When a new session with a serial port is created, current configuration will be saved in struct termios oldtio , oldtio is get from device by API: int tcgetattr(int fd, struct termios *termios_p); A new configuration struct termios newtio is created and applied to device by API: int tcsetattr(int fd, int optional_actions, const struct termios *termios_p); After applying compatible configuration, userspace application can communicate with serial port by calling read and write system call with file description fd .","title":"Userspace"},{"location":"ldd/uart/uart/#kernelspace","text":"Referring to: Linux serial drivers - bootlin.com - said about how to write an UART device driver. To be properly intergrated in a Linux system, serial ports like UART must be visible as TTY devices from user space application. Therefore, the serial driver must be part of the kernle TTY subsystem.","title":"Kernelspace"},{"location":"linux_kernel_dev/kernel_data_structure/","text":"Kernel Data Structure References [1] Linux Kernel Development, 3nd Linked List The Linked List Structure Linked list is popular data structure that is used in programming. The Linux Kernel approach is different. Instead of turning the structure into a linked list, the Linux approach is to embed a linked list noed in the structure! The linked-list code is declared in the header file linux/list.h> and the data structure is simple: list_head: include/list.h#L24 struct list_head { struct list_head *next struct list_head *prev; }; embed in a structure: struct fox { unsigned long tail_length; /* length in centimeters of tail */ unsigned long weight; /* weight in kilograms */ bool is_fantastic; /* is this fox fantastic? */ struct list_head list; /* list of all fox structures */ }; From a pointer that points to the struct list_head in a structure, we can get pointer to this structure by using macro list_entry (see container_of() ): #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) Example: struct fox red_fox, *fox_ptr; // fox_ptr is pointing to nothing struct list_head *list_ptr = red_fox.list; // make list_ptr point to struct list inside red_fox fox_ptr = list_entry(list_ptr, struct fox, list); // fox_ptr now is pointing to red_fox Defining a Linked List There are two ways to define a linked-list: Defining listed-list with the first entry: Dynamic Allocation, struct fox *red_fox; red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL); red_fox- tail_length = 40; red_fox- weight = 6; red_fox- is_fantastic = false; INIT_LIST_HEAD( red_fox- list); And static alocation, struct fox red_fox = { .tail_length = 40, .weight = 6, .list = LIST_HEAD_INIT(red_fox.list), }; Defining a empty linked-list: static LIST_HEAD(fox_list); The second approach is used popularly in Linux Kernel (see spi.c). Traversing Linked Lists The kernel (thank goodness) provides a nice set of interfaces for traversing linked lists and referencing the data structures that include them. The Basic Approach struct list_head *p; struct fox *f; list_for_each(p, fox_list) { /* p points to an entry (struct list_head) in the list */ f = list_entry(p, struct fox, list); // We need to use list_entry to get the fox structure } The Usable Approach struct fox *f; list_for_each_entry(f, fox_list, list) { /* on each iteration, \u2018f\u2019 points to the next fox structure ... */ } container_of() container_of: include/linux/kerne.h#108 #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)- member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) Assume that we have a structure: struct data { int data1; int data2; } And a pointer int *child_ptr point to data2 which is a member of struct data . int *child_ptr = data2; We can user container_of() to get a pointer pointing to struct data . struct data *data_ptr = container_of(child_ptr, struct container, data2); Can we implement \"container_of\" in c for user space application?","title":"Kernel Data Structure"},{"location":"linux_kernel_dev/kernel_data_structure/#kernel-data-structure","text":"","title":"Kernel Data Structure"},{"location":"linux_kernel_dev/kernel_data_structure/#references","text":"[1] Linux Kernel Development, 3nd","title":"References"},{"location":"linux_kernel_dev/kernel_data_structure/#linked-list","text":"","title":"Linked List"},{"location":"linux_kernel_dev/kernel_data_structure/#the-linked-list-structure","text":"Linked list is popular data structure that is used in programming. The Linux Kernel approach is different. Instead of turning the structure into a linked list, the Linux approach is to embed a linked list noed in the structure! The linked-list code is declared in the header file linux/list.h> and the data structure is simple: list_head: include/list.h#L24 struct list_head { struct list_head *next struct list_head *prev; }; embed in a structure: struct fox { unsigned long tail_length; /* length in centimeters of tail */ unsigned long weight; /* weight in kilograms */ bool is_fantastic; /* is this fox fantastic? */ struct list_head list; /* list of all fox structures */ }; From a pointer that points to the struct list_head in a structure, we can get pointer to this structure by using macro list_entry (see container_of() ): #define list_entry(ptr, type, member) \\ container_of(ptr, type, member) Example: struct fox red_fox, *fox_ptr; // fox_ptr is pointing to nothing struct list_head *list_ptr = red_fox.list; // make list_ptr point to struct list inside red_fox fox_ptr = list_entry(list_ptr, struct fox, list); // fox_ptr now is pointing to red_fox","title":"The Linked List Structure"},{"location":"linux_kernel_dev/kernel_data_structure/#defining-a-linked-list","text":"There are two ways to define a linked-list: Defining listed-list with the first entry: Dynamic Allocation, struct fox *red_fox; red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL); red_fox- tail_length = 40; red_fox- weight = 6; red_fox- is_fantastic = false; INIT_LIST_HEAD( red_fox- list); And static alocation, struct fox red_fox = { .tail_length = 40, .weight = 6, .list = LIST_HEAD_INIT(red_fox.list), }; Defining a empty linked-list: static LIST_HEAD(fox_list); The second approach is used popularly in Linux Kernel (see spi.c).","title":"Defining a Linked List"},{"location":"linux_kernel_dev/kernel_data_structure/#traversing-linked-lists","text":"The kernel (thank goodness) provides a nice set of interfaces for traversing linked lists and referencing the data structures that include them. The Basic Approach struct list_head *p; struct fox *f; list_for_each(p, fox_list) { /* p points to an entry (struct list_head) in the list */ f = list_entry(p, struct fox, list); // We need to use list_entry to get the fox structure } The Usable Approach struct fox *f; list_for_each_entry(f, fox_list, list) { /* on each iteration, \u2018f\u2019 points to the next fox structure ... */ }","title":"Traversing Linked Lists"},{"location":"linux_kernel_dev/kernel_data_structure/#container_of","text":"container_of: include/linux/kerne.h#108 #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)- member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) Assume that we have a structure: struct data { int data1; int data2; } And a pointer int *child_ptr point to data2 which is a member of struct data . int *child_ptr = data2; We can user container_of() to get a pointer pointing to struct data . struct data *data_ptr = container_of(child_ptr, struct container, data2); Can we implement \"container_of\" in c for user space application?","title":"container_of()"},{"location":"linux_kernel_dev/kernel_user_space/","text":"Kernel Space, User Space Interfaces http://wiki.tldp.org/kernel_user_space_howto","title":"Kernel Space, User Space Interfaces"},{"location":"linux_kernel_dev/kernel_user_space/#kernel-space-user-space-interfaces","text":"http://wiki.tldp.org/kernel_user_space_howto","title":"Kernel Space, User Space Interfaces"},{"location":"lnx_es/es/","text":"Embedded Linux System Development Embedded Linux System Development - What I have to do? Bring up a board Bootloader Linux Kernel Linux Device Driver GPIO Subsystem https://lwn.net/Articles/532714/","title":"Overview"},{"location":"lnx_es/es/#embedded-linux-system-development","text":"","title":"Embedded Linux System Development"},{"location":"lnx_es/es/#embedded-linux-system-development-what-i-have-to-do","text":"","title":"Embedded Linux System Development - What I have to do?"},{"location":"lnx_es/es/#bring-up-a-board","text":"","title":"Bring up a board"},{"location":"lnx_es/es/#bootloader","text":"","title":"Bootloader"},{"location":"lnx_es/es/#linux-kernel","text":"","title":"Linux Kernel"},{"location":"lnx_es/es/#linux-device-driver","text":"","title":"Linux Device Driver"},{"location":"lnx_es/es/#gpio-subsystem","text":"https://lwn.net/Articles/532714/","title":"GPIO Subsystem"},{"location":"lnx_es/ptlnx_20174/","text":"Petalinux 2017.4 technical note Vu Tang - 2/2019 Introdutions T\u00e0i li\u1ec7u n\u00e0y l\u00e0 b\u00e1o c\u00e1o t\u00ecm hi\u1ec3u petalinux 2017.4. T\u1ed5ng k\u1ebft nh\u1eefng kinh nghi\u1ec7m l\u00e0m vi\u1ec7c v\u1edbi phi\u00ean b\u1ea3n m\u1edbi n\u00e0y. Petalinux 2017.4 l\u00e0 m\u1ed9t th\u1ec3 hi\u1ec7n r\u00f5 r\u00e0ng c\u1ee7a vi\u1ec7c \u1ee9ng d\u1ee5ng Yocto project trong qu\u00e1 tr\u00ecnh ph\u00e1t tri\u1ec3n m\u1ed9t h\u1ec7 nh\u00fang Linux. \u0110\u1ec3 hi\u1ec3u r\u00f5 h\u01a1n qu\u00e1 tr\u00ecnh l\u00e0m vi\u1ec7c c\u1ee7a petalinux 2017.4, c\u1ea7n t\u00ecm hi\u1ec3u r\u00f5 v\u1ec1 nguy\u00ean t\u1eafc ho\u1ea1t \u0111\u1ed9ng c\u1ee7a Yocto project. Tips Speed up sstate checking https://forums.xilinx.com/t5/Embedded-Linux/Checking-sstate-mirror-taking-forever/td-p/775404 Diable sstate online in Yocto Mounting SD card automatically Refer PetaLinux Yocto Tips (xilinx-wiki.atlassian.net) for step-by-step instructions. Worknote build target when use petalinux build is petalinux-user-image.bb. Bitbake file dir: [project dir]/project-spec/meta-plnx-generated/recipes-core/images/petalinux-user-image.bb based-bitbake file be used for all project is found at: [installation dir]/components/yocto/source/ petalinux-build -x clean/distclean is not affect to download dir Removing build/tmp dir need to rebuild all project (except fetching source code). This job takes a while. petalinux-build -x distclean will call bitbake -c cleansstate - what is cleansstate? clean - bitbake -c clean. what is defference btw clean cleansstate $WORKDIR: build/tmp/work/plnx_arm-xilinx-linux-gnueabi/libsample-tar/1.0-r0 Create and initialize a project Qu\u00e1 tr\u00ecnh kh\u1edfi t\u1ea1o project (1) v\u00e0 import hdf (2) ti\u1ebfn h\u00e0nh t\u01b0\u01a1ng t\u1ef1 v\u1edbi petalinux 2015.4 (xem th\u00eam ug1144 \u0111\u1ec3 bi\u1ebft v\u1ec1 c\u00e1c cmd t\u01b0\u01a1ng \u1ee9ng cho t\u1eebng qu\u00e1 tr\u00ecnh). \u251c\u2500\u2500 config.project \u2514\u2500\u2500 project-spec \u251c\u2500\u2500 attributes \u251c\u2500\u2500 configs \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 rootfs_config \u251c\u2500\u2500 hw-description \u2502 \u2514\u2500\u2500 metadata \u2514\u2500\u2500 meta-user \u251c\u2500\u2500 conf \u251c\u2500\u2500 COPYING.MIT \u251c\u2500\u2500 README \u251c\u2500\u2500 recipes-apps \u2514\u2500\u2500 recipes-bsp K\u1ebft th\u00fac qu\u00e1 tr\u00ecnh (1), project \u0111\u01b0\u1ee3c t\u1ea1o v\u1edbi th\u01b0 m\u1ee5c \u201cproject-spec\u201d. Trong \u0111\u00f3: Th\u01b0 m\u1ee5c con \u201cconfigs\u201d ch\u1ee9a c\u00e1c c\u1ea5u h\u00ecnh c\u1ee7a project (c\u00e1c c\u1ea5u h\u00ecnh n\u00e0y \u0111\u01b0\u1ee3c thay \u0111\u1ed5i b\u1eb1ng h\u1ecd c\u00e2u l\u1ec7nh \u201cpetalinux-config\u201d). Th\u01b0 m\u1ee5c con \u201chw-description\u201d tr\u1ed1ng. Th\u01b0 m\u1ee5c con \u201cmeta-user\u201d ch\u1ee9a c\u00e1c recipes li\u00ean quan \u0111\u1ebfn user-apps v\u00e0 bsp. Ngoai ra th\u01b0 m\u1ee5c n\u00e0y c\u00f2n ch\u1ee9a trong ./conf c\u00e1c c\u1ea5u h\u00ecnh li\u00ean quan \u0111\u1ebfn Yocto cho Layer meta-user. K\u1ebft th\u00fac qu\u00e1 tr\u00ecnh (2), c\u1ea5u tr\u00fac th\u01b0 m\u1ee5c c\u1ee7a project bi\u1ebfn \u0111\u1ed5i nh\u01b0 h\u00ecnh v\u1ebd d\u01b0\u1edbi \u0111\u00e2y. \u251c\u2500\u2500 build \u2502 \u251c\u2500\u2500 cache \u2502 \u251c\u2500\u2500 conf \u2502 \u251c\u2500\u2500 config.log \u2502 \u251c\u2500\u2500 misc \u2502 \u2514\u2500\u2500 tmp \u251c\u2500\u2500 components \u2502 \u2514\u2500\u2500 plnx_workspace \u251c\u2500\u2500 config.project \u2514\u2500\u2500 project-spec \u251c\u2500\u2500 attributes \u251c\u2500\u2500 configs \u251c\u2500\u2500 hw-description \u251c\u2500\u2500 meta-plnx-generated \u251c\u2500\u2500 meta-user \u2514\u2500\u2500 yocto-layer.log Trong \u0111\u00f3, xu\u1ea5t hi\u1ec7n th\u00eam m\u1ed9t s\u1ed1 th\u01b0 m\u1ee5c quan tr\u1ecdng sau: Th\u01b0 m\u1ee5c \u201cbuild\u201d l\u00e0 th\u01b0 m\u1ee5c \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ebf ti\u1ebfn h\u00e0nh c\u00e1c giai \u0111o\u1ea1n trong qu\u00e1 tr\u00ecnh build project. Trong \u0111\u00f3 k\u1ebft qu\u1ea3 trung gian trong c\u00e1c qu\u00e1 tr\u00ecnh build \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef t\u1ea1i \u201ctmp\u201d. Ngo\u00e0i ra, trong c\u00e1c qu\u00e1 tr\u00ecnh ti\u1ebfp theo trong \u201cbuild\u201d s\u1ebd xu\u1ea5t hi\u1ec7n th\u00eam th\u01b0 m\u1ee5c \u201cdownloads\u201d th\u1ef1c hi\u1ec7n ch\u1ee9c n\u0103ng l\u01b0u tr\u1eef c\u00e1c package \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n trong qu\u00e1 tr\u00ecnh \u201cdo_fetch\u201d. Th\u01b0 m\u1ee5c \u201ccomponents\u201d trong c\u00e1c phi\u00ean b\u1ea3n petalinux tr\u01b0\u1edbc s\u1ebd \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 ch\u1ee9a source code li\u00ean quan \u0111\u1ebfn c\u00e1c customed-component c\u1ee7a user. Trong phi\u00ean b\u1ea3n n\u00e0y ch\u01b0a x\u00e1c \u0111\u1ecbnh \u0111\u01b0\u1ee3c ch\u1ee9c n\u0103ng c\u1ee7a th\u01b0 m\u1ee5c component. Xu\u1ea5t hi\u1ec7n th\u00eam Yocto layer \u201cmeta-plnx-generated\u201d trong th\u01b0 m\u1ee5c \u201cproject-spec\u201d, ch\u1ee9a c\u00e1c Yocto recipes li\u00ean quan \u0111\u1ebfn kernel, core, bsp. Xem th\u00eam Apendix A trong t\u00e0i li\u1ec7u ug1144 \u0111\u1ec3 bi\u1ebft th\u00eam th\u00f4ng tin v\u1ec1 Petalinux project structure. Build a new project without Internet \u0110\u1ec3 th\u1ef1c hi\u1ec7n build, ch\u1ea1y l\u1ec7nh \u201cpetalinux-build\u201d. Pre-build configuration B\u1ea3n ch\u1ea5t c\u1ee7a qu\u00e1 tr\u00ecnh n\u00e0y l\u00e0 g\u1ecdi \u0111\u1ebfn target \u201cpetalinux-user-image\u201d c\u1ee7a Yocto project. \u201cChecking sstate mirror object availability\u201d m\u1ea5t r\u1ea5t nhi\u1ec1u th\u1eddi gian \u0111\u1ec3 th\u1ef1c hi\u1ec7n? - Ti\u1ebfn h\u00e0nh t\u1eaft b\u1ecf ch\u1ee9c n\u0103ng check n\u00e0y trong petalinux-config Yocto sstate. Xu\u1ea5t hi\u1ec7n l\u1ed7i li\u00ean quan \u0111\u1ebfn bitbake n\u1ebfu d\u1eebng qu\u00e1 tr\u00ecnh build \u0111\u1ed9t ng\u1ed9t (v\u00ed d\u1ee5 d\u1eebng b\u1eb1ng t\u1ed5 h\u1ee3p ph\u00edm Ctl+C). Solution here: Re-init environment: /home/user/Xilinx/Petalinux/settings.sh /home/user/Xilinx/Petalinux/components/yocto/source/aarch64/environment-setup-aarch64-xilinx-linux Remove ./build/bitbake.lock. C\u00e1c c\u1ea5u h\u00ecnh c\u1ee7a project \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef \u1edf: project-spec/configs/config Do_fetch - What is problem? Trong qu\u00e1 tr\u00ecnh build, petalinux s\u1ebd th\u1ef1c hi\u1ec7n l\u1ea5y c\u00e1c g\u00f3i c\u00f3 s\u1eb5n trong th\u01b0 m\u1ee5c c\u00e0i \u0111\u1eb7t c\u1ee7a petalinux, \u0111\u01b0\u1eddng d\u1eabn nh\u01b0 sau: [Instalation Direction]/components/yocto/downloads. Ngo\u00e0i ra petalinux ti\u1ebfn h\u00e0nh download t\u1eeb Internet th\u00eam c\u00e1c g\u00f3i nh\u01b0: (1) gcc-source-linaro-6.2-linaro-6.2-r2016.11 (2) binutils-cross-arm-linaro-2.27-r2016.10 (3) u-boot-mkimage-native-v2016.03+gitAUTOINC+df61a74e68-r0 (4) binutils-native-linaro-2.27-r2016.10 ... N\u1ebfu trong qu\u00e1 tr\u00ecnh build kh\u00f4ng c\u00f3 k\u1ebft n\u1ed1i Internet s\u1ebd d\u1eabn \u0111\u1ebfn c\u00e1c th\u00f4ng b\u00e1o build l\u1ed7i. V\u00ed d\u1ee5 nh\u01b0: \u201cu-boot-mkimage-native-v2016.03+gitAUTOINC+df61a74e68-r0 do_fetch: Fetcher failure\u201d Nh\u01b0 v\u1eady, b\u1ea3n c\u00e0i \u0111\u1eb7t m\u1eb7c \u0111\u1ecbnh c\u1ee7a petalinux kh\u00f4ng ch\u1ee9a \u0111\u1ee7 c\u00e1c g\u00f3i ph\u1ea7n m\u1ec1m s\u1eed d\u1ee5ng cho qu\u00e1 tr\u00ecnh Yocto build (?). C\u1ea7n c\u00f3 th\u00eam c\u00e1c g\u00f3i sau: git2_git.linaro.org.toolchain.binutils-gdb.git t\u01b0\u01a1ng \u1ee9ng v\u1edbi (2) v\u00e0 (4) git2_git.linaro.org.toolchain.gcc.git t\u01b0\u01a1ng \u1ee9ng v\u1edbi (1) Linaro - what is this? External kernel - How to? Boot from SD card V\u1ec1 c\u01a1 b\u1ea3n, boot t\u1eeb SD Card \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n gi\u1ed1ng v\u1edbi h\u01b0\u1edbng d\u1eabn trong m\u1ee5c Zedboard. T\u1ec7p rootfs.cpio \u0111\u01b0\u1ee3c ch\u1ee9a trong th\u01b0 m\u1ee5c /image/linux/ s\u1eb5n s\u00e0ng cho qu\u00e1 tr\u00ecnh \u0111\u01b0a l\u00ean th\u1ebb nh\u1edb. Add user custom package B\u1ea3n ch\u1ea5t qu\u1ea3n l\u00fd g\u00f3i ph\u1ea7n m\u1ec1m trong petalinux l\u00e0 Yocto project. C\u00e1c g\u00f3i ph\u1ea7n m\u1ec1m c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c download t\u1eeb c\u00e1c online repository. Trong m\u1ee5c n\u00e0y s\u1ebd l\u1ea5y v\u00ed d\u1ee5 v\u1ec1 m\u1ed9t g\u00f3i ph\u1ea7n m\u1ec1m ph\u1ed5 bi\u1ebfn, hay \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng trong qu\u00e1 tr\u00ecnh \u0111\u00e1nh gi\u00e1 ch\u1ea5t l\u01b0\u1ee3ng m\u1ea1ng: IPERF. Petalinux s\u1ebd th\u1ef1c hi\u1ec7n t\u1ea3i source code c\u1ee7a iperf t\u1eeb Github sau \u0111\u00f3 ti\u1ebfn h\u00e0nh c\u1ea5u h\u00ecnh, build v\u00e0 t\u00edch h\u1ee3p v\u00e0o h\u1ec7 th\u1ed1ng. Khi kh\u1edfi t\u1ea1o m\u1ed9t \u1ee9ng d\u1ee5ng (apps) m\u1edbi, m\u1ed9t package \u0111\u01b0\u1ee3c t\u1ea1o t\u1ea1i project-spec/meta-user/recipes-apps . C\u1ea5u tr\u00fac c\u1ee7a m\u1ed9t recipes nh\u01b0 sau: vux-iperf/ \u251c\u2500\u2500 files \u2502 \u251c\u2500\u2500 0002-Remove-pg-from-profile_CFLAGS.patch \u2502 \u2514\u2500\u2500 automake-foreign.patch \u251c\u2500\u2500 README \u2514\u2500\u2500 vux-iperf.bb Trong v\u00ed d\u1ee5 l\u00e0 c\u1ea5u h\u00ecnh \u0111\u1ec3 build b\u1ea3n ph\u1ea7n m\u1ec1m iperf3. Bitbake file cho recipes n\u00e0y \u0111\u01b0\u1ee3c t\u1ea3i t\u1ea1i iperf3 3.6 (layers.openembedded.org). Trong file vux-iperf.bb c\u00f3 m\u1ed9t s\u1ed1 kh\u00e1i ni\u1ec7m v\u00e0 th\u00f4ng tin c\u1ea7n l\u01b0u \u00fd nh\u01b0 sau. \u0110\u01b0\u1eddng d\u1eabn \u0111\u1ebfn source code c\u1ee7a package Tham s\u1ed1 SRC_URI ch\u1ee9a \u0111\u01b0\u1eddng d\u1eabn \u0111\u1ebfn source code c\u1ee7a pakcage. Th\u00f4ng qua th\u00f4ng tin ch\u1ee9a trong \u0111\u01b0\u1eddng d\u1eabn n\u00e0y, bitbake th\u1ef1c hi\u1ec7n nhi\u1ec7m v\u1ee5 do_fetch. SRC_URI = \"git://github.com/esnet/iperf.git \\ file://automake-foreign.patch \\ Trong v\u00ed d\u1ee5 n\u00e0y, SRC_URI ch\u1ec9 \u0111\u1ebfn m\u1ed9t git repository c\u1ee7a esnet. Ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 truy c\u1eadp tr\u1ef1c ti\u1ebfp v\u00e0o repo n\u00e0y \u0111\u1ec3 xem source code. Ngo\u00e0i ra SRC_URI ch\u1ec9 \u0111\u1ebfn m\u1ed9t file \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef local ch\u1ee9a b\u1ea3n patch. B\u1ea3n patch n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y tr\u00ean openembedded.org. Revision c\u1ee7a source code Tham s\u1ed1 SRCREV ch\u1ec9 cho bitbake bi\u1ebft \u0111\u01b0\u1ee3c revision n\u00e0o c\u1ee7a source code c\u1ea7n \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 build package. SRCREV = \"88d907f7fb58bfab5d086c5da60c922e1c582c92\" Ngo\u00e0i ra, SRCREV c\u00f2n c\u00f3 th\u1ec3 cung c\u1ea5p th\u00eam c\u00e1c th\u00f4ng tin nh\u01b0 sau: protocol: giao th\u1ee9c s\u1eed d\u1ee5ng \u0111\u1ec3 fetch source code (protocol=https...) branch: branch mong mu\u1ed1n fetch source code (branch=master...) T\u01b0\u01a1ng \u1ee9ng v\u1edbi m\u1ed7i revision ch\u1ee9a m\u1ed9t file LICENSE \u0111i k\u00e8m v\u1edbi MD5SUM. LIC_FILES_CHKSUM = \"file://LICENSE;md5=d098223e44bdd19585315ee75cd9d2d7\" L\u01b0u \u00fd r\u1eb1ng LIC_FILES c\u00f3 th\u1ec3 l\u00e0 LICENSE ho\u1eb7c b\u1ea5t c\u1ee9 t\u00ean kh\u00e1c.","title":"Petalinux 2017.4"},{"location":"lnx_es/ptlnx_20174/#petalinux-20174-technical-note","text":"Vu Tang - 2/2019","title":"Petalinux 2017.4 technical note"},{"location":"lnx_es/ptlnx_20174/#introdutions","text":"T\u00e0i li\u1ec7u n\u00e0y l\u00e0 b\u00e1o c\u00e1o t\u00ecm hi\u1ec3u petalinux 2017.4. T\u1ed5ng k\u1ebft nh\u1eefng kinh nghi\u1ec7m l\u00e0m vi\u1ec7c v\u1edbi phi\u00ean b\u1ea3n m\u1edbi n\u00e0y. Petalinux 2017.4 l\u00e0 m\u1ed9t th\u1ec3 hi\u1ec7n r\u00f5 r\u00e0ng c\u1ee7a vi\u1ec7c \u1ee9ng d\u1ee5ng Yocto project trong qu\u00e1 tr\u00ecnh ph\u00e1t tri\u1ec3n m\u1ed9t h\u1ec7 nh\u00fang Linux. \u0110\u1ec3 hi\u1ec3u r\u00f5 h\u01a1n qu\u00e1 tr\u00ecnh l\u00e0m vi\u1ec7c c\u1ee7a petalinux 2017.4, c\u1ea7n t\u00ecm hi\u1ec3u r\u00f5 v\u1ec1 nguy\u00ean t\u1eafc ho\u1ea1t \u0111\u1ed9ng c\u1ee7a Yocto project.","title":"Introdutions"},{"location":"lnx_es/ptlnx_20174/#tips","text":"Speed up sstate checking https://forums.xilinx.com/t5/Embedded-Linux/Checking-sstate-mirror-taking-forever/td-p/775404 Diable sstate online in Yocto Mounting SD card automatically Refer PetaLinux Yocto Tips (xilinx-wiki.atlassian.net) for step-by-step instructions.","title":"Tips"},{"location":"lnx_es/ptlnx_20174/#worknote","text":"build target when use petalinux build is petalinux-user-image.bb. Bitbake file dir: [project dir]/project-spec/meta-plnx-generated/recipes-core/images/petalinux-user-image.bb based-bitbake file be used for all project is found at: [installation dir]/components/yocto/source/ petalinux-build -x clean/distclean is not affect to download dir Removing build/tmp dir need to rebuild all project (except fetching source code). This job takes a while. petalinux-build -x distclean will call bitbake -c cleansstate - what is cleansstate? clean - bitbake -c clean. what is defference btw clean cleansstate $WORKDIR: build/tmp/work/plnx_arm-xilinx-linux-gnueabi/libsample-tar/1.0-r0","title":"Worknote"},{"location":"lnx_es/ptlnx_20174/#create-and-initialize-a-project","text":"Qu\u00e1 tr\u00ecnh kh\u1edfi t\u1ea1o project (1) v\u00e0 import hdf (2) ti\u1ebfn h\u00e0nh t\u01b0\u01a1ng t\u1ef1 v\u1edbi petalinux 2015.4 (xem th\u00eam ug1144 \u0111\u1ec3 bi\u1ebft v\u1ec1 c\u00e1c cmd t\u01b0\u01a1ng \u1ee9ng cho t\u1eebng qu\u00e1 tr\u00ecnh). \u251c\u2500\u2500 config.project \u2514\u2500\u2500 project-spec \u251c\u2500\u2500 attributes \u251c\u2500\u2500 configs \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 rootfs_config \u251c\u2500\u2500 hw-description \u2502 \u2514\u2500\u2500 metadata \u2514\u2500\u2500 meta-user \u251c\u2500\u2500 conf \u251c\u2500\u2500 COPYING.MIT \u251c\u2500\u2500 README \u251c\u2500\u2500 recipes-apps \u2514\u2500\u2500 recipes-bsp K\u1ebft th\u00fac qu\u00e1 tr\u00ecnh (1), project \u0111\u01b0\u1ee3c t\u1ea1o v\u1edbi th\u01b0 m\u1ee5c \u201cproject-spec\u201d. Trong \u0111\u00f3: Th\u01b0 m\u1ee5c con \u201cconfigs\u201d ch\u1ee9a c\u00e1c c\u1ea5u h\u00ecnh c\u1ee7a project (c\u00e1c c\u1ea5u h\u00ecnh n\u00e0y \u0111\u01b0\u1ee3c thay \u0111\u1ed5i b\u1eb1ng h\u1ecd c\u00e2u l\u1ec7nh \u201cpetalinux-config\u201d). Th\u01b0 m\u1ee5c con \u201chw-description\u201d tr\u1ed1ng. Th\u01b0 m\u1ee5c con \u201cmeta-user\u201d ch\u1ee9a c\u00e1c recipes li\u00ean quan \u0111\u1ebfn user-apps v\u00e0 bsp. Ngoai ra th\u01b0 m\u1ee5c n\u00e0y c\u00f2n ch\u1ee9a trong ./conf c\u00e1c c\u1ea5u h\u00ecnh li\u00ean quan \u0111\u1ebfn Yocto cho Layer meta-user. K\u1ebft th\u00fac qu\u00e1 tr\u00ecnh (2), c\u1ea5u tr\u00fac th\u01b0 m\u1ee5c c\u1ee7a project bi\u1ebfn \u0111\u1ed5i nh\u01b0 h\u00ecnh v\u1ebd d\u01b0\u1edbi \u0111\u00e2y. \u251c\u2500\u2500 build \u2502 \u251c\u2500\u2500 cache \u2502 \u251c\u2500\u2500 conf \u2502 \u251c\u2500\u2500 config.log \u2502 \u251c\u2500\u2500 misc \u2502 \u2514\u2500\u2500 tmp \u251c\u2500\u2500 components \u2502 \u2514\u2500\u2500 plnx_workspace \u251c\u2500\u2500 config.project \u2514\u2500\u2500 project-spec \u251c\u2500\u2500 attributes \u251c\u2500\u2500 configs \u251c\u2500\u2500 hw-description \u251c\u2500\u2500 meta-plnx-generated \u251c\u2500\u2500 meta-user \u2514\u2500\u2500 yocto-layer.log Trong \u0111\u00f3, xu\u1ea5t hi\u1ec7n th\u00eam m\u1ed9t s\u1ed1 th\u01b0 m\u1ee5c quan tr\u1ecdng sau: Th\u01b0 m\u1ee5c \u201cbuild\u201d l\u00e0 th\u01b0 m\u1ee5c \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ebf ti\u1ebfn h\u00e0nh c\u00e1c giai \u0111o\u1ea1n trong qu\u00e1 tr\u00ecnh build project. Trong \u0111\u00f3 k\u1ebft qu\u1ea3 trung gian trong c\u00e1c qu\u00e1 tr\u00ecnh build \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef t\u1ea1i \u201ctmp\u201d. Ngo\u00e0i ra, trong c\u00e1c qu\u00e1 tr\u00ecnh ti\u1ebfp theo trong \u201cbuild\u201d s\u1ebd xu\u1ea5t hi\u1ec7n th\u00eam th\u01b0 m\u1ee5c \u201cdownloads\u201d th\u1ef1c hi\u1ec7n ch\u1ee9c n\u0103ng l\u01b0u tr\u1eef c\u00e1c package \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n trong qu\u00e1 tr\u00ecnh \u201cdo_fetch\u201d. Th\u01b0 m\u1ee5c \u201ccomponents\u201d trong c\u00e1c phi\u00ean b\u1ea3n petalinux tr\u01b0\u1edbc s\u1ebd \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 ch\u1ee9a source code li\u00ean quan \u0111\u1ebfn c\u00e1c customed-component c\u1ee7a user. Trong phi\u00ean b\u1ea3n n\u00e0y ch\u01b0a x\u00e1c \u0111\u1ecbnh \u0111\u01b0\u1ee3c ch\u1ee9c n\u0103ng c\u1ee7a th\u01b0 m\u1ee5c component. Xu\u1ea5t hi\u1ec7n th\u00eam Yocto layer \u201cmeta-plnx-generated\u201d trong th\u01b0 m\u1ee5c \u201cproject-spec\u201d, ch\u1ee9a c\u00e1c Yocto recipes li\u00ean quan \u0111\u1ebfn kernel, core, bsp. Xem th\u00eam Apendix A trong t\u00e0i li\u1ec7u ug1144 \u0111\u1ec3 bi\u1ebft th\u00eam th\u00f4ng tin v\u1ec1 Petalinux project structure.","title":"Create and initialize a project"},{"location":"lnx_es/ptlnx_20174/#build-a-new-project-without-internet","text":"\u0110\u1ec3 th\u1ef1c hi\u1ec7n build, ch\u1ea1y l\u1ec7nh \u201cpetalinux-build\u201d. Pre-build configuration B\u1ea3n ch\u1ea5t c\u1ee7a qu\u00e1 tr\u00ecnh n\u00e0y l\u00e0 g\u1ecdi \u0111\u1ebfn target \u201cpetalinux-user-image\u201d c\u1ee7a Yocto project. \u201cChecking sstate mirror object availability\u201d m\u1ea5t r\u1ea5t nhi\u1ec1u th\u1eddi gian \u0111\u1ec3 th\u1ef1c hi\u1ec7n? - Ti\u1ebfn h\u00e0nh t\u1eaft b\u1ecf ch\u1ee9c n\u0103ng check n\u00e0y trong petalinux-config Yocto sstate. Xu\u1ea5t hi\u1ec7n l\u1ed7i li\u00ean quan \u0111\u1ebfn bitbake n\u1ebfu d\u1eebng qu\u00e1 tr\u00ecnh build \u0111\u1ed9t ng\u1ed9t (v\u00ed d\u1ee5 d\u1eebng b\u1eb1ng t\u1ed5 h\u1ee3p ph\u00edm Ctl+C). Solution here: Re-init environment: /home/user/Xilinx/Petalinux/settings.sh /home/user/Xilinx/Petalinux/components/yocto/source/aarch64/environment-setup-aarch64-xilinx-linux Remove ./build/bitbake.lock. C\u00e1c c\u1ea5u h\u00ecnh c\u1ee7a project \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef \u1edf: project-spec/configs/config Do_fetch - What is problem? Trong qu\u00e1 tr\u00ecnh build, petalinux s\u1ebd th\u1ef1c hi\u1ec7n l\u1ea5y c\u00e1c g\u00f3i c\u00f3 s\u1eb5n trong th\u01b0 m\u1ee5c c\u00e0i \u0111\u1eb7t c\u1ee7a petalinux, \u0111\u01b0\u1eddng d\u1eabn nh\u01b0 sau: [Instalation Direction]/components/yocto/downloads. Ngo\u00e0i ra petalinux ti\u1ebfn h\u00e0nh download t\u1eeb Internet th\u00eam c\u00e1c g\u00f3i nh\u01b0: (1) gcc-source-linaro-6.2-linaro-6.2-r2016.11 (2) binutils-cross-arm-linaro-2.27-r2016.10 (3) u-boot-mkimage-native-v2016.03+gitAUTOINC+df61a74e68-r0 (4) binutils-native-linaro-2.27-r2016.10 ... N\u1ebfu trong qu\u00e1 tr\u00ecnh build kh\u00f4ng c\u00f3 k\u1ebft n\u1ed1i Internet s\u1ebd d\u1eabn \u0111\u1ebfn c\u00e1c th\u00f4ng b\u00e1o build l\u1ed7i. V\u00ed d\u1ee5 nh\u01b0: \u201cu-boot-mkimage-native-v2016.03+gitAUTOINC+df61a74e68-r0 do_fetch: Fetcher failure\u201d Nh\u01b0 v\u1eady, b\u1ea3n c\u00e0i \u0111\u1eb7t m\u1eb7c \u0111\u1ecbnh c\u1ee7a petalinux kh\u00f4ng ch\u1ee9a \u0111\u1ee7 c\u00e1c g\u00f3i ph\u1ea7n m\u1ec1m s\u1eed d\u1ee5ng cho qu\u00e1 tr\u00ecnh Yocto build (?). C\u1ea7n c\u00f3 th\u00eam c\u00e1c g\u00f3i sau: git2_git.linaro.org.toolchain.binutils-gdb.git t\u01b0\u01a1ng \u1ee9ng v\u1edbi (2) v\u00e0 (4) git2_git.linaro.org.toolchain.gcc.git t\u01b0\u01a1ng \u1ee9ng v\u1edbi (1) Linaro - what is this? External kernel - How to?","title":"Build a new project without Internet"},{"location":"lnx_es/ptlnx_20174/#boot-from-sd-card","text":"V\u1ec1 c\u01a1 b\u1ea3n, boot t\u1eeb SD Card \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n gi\u1ed1ng v\u1edbi h\u01b0\u1edbng d\u1eabn trong m\u1ee5c Zedboard. T\u1ec7p rootfs.cpio \u0111\u01b0\u1ee3c ch\u1ee9a trong th\u01b0 m\u1ee5c /image/linux/ s\u1eb5n s\u00e0ng cho qu\u00e1 tr\u00ecnh \u0111\u01b0a l\u00ean th\u1ebb nh\u1edb.","title":"Boot from SD card"},{"location":"lnx_es/ptlnx_20174/#add-user-custom-package","text":"B\u1ea3n ch\u1ea5t qu\u1ea3n l\u00fd g\u00f3i ph\u1ea7n m\u1ec1m trong petalinux l\u00e0 Yocto project. C\u00e1c g\u00f3i ph\u1ea7n m\u1ec1m c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c download t\u1eeb c\u00e1c online repository. Trong m\u1ee5c n\u00e0y s\u1ebd l\u1ea5y v\u00ed d\u1ee5 v\u1ec1 m\u1ed9t g\u00f3i ph\u1ea7n m\u1ec1m ph\u1ed5 bi\u1ebfn, hay \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng trong qu\u00e1 tr\u00ecnh \u0111\u00e1nh gi\u00e1 ch\u1ea5t l\u01b0\u1ee3ng m\u1ea1ng: IPERF. Petalinux s\u1ebd th\u1ef1c hi\u1ec7n t\u1ea3i source code c\u1ee7a iperf t\u1eeb Github sau \u0111\u00f3 ti\u1ebfn h\u00e0nh c\u1ea5u h\u00ecnh, build v\u00e0 t\u00edch h\u1ee3p v\u00e0o h\u1ec7 th\u1ed1ng. Khi kh\u1edfi t\u1ea1o m\u1ed9t \u1ee9ng d\u1ee5ng (apps) m\u1edbi, m\u1ed9t package \u0111\u01b0\u1ee3c t\u1ea1o t\u1ea1i project-spec/meta-user/recipes-apps . C\u1ea5u tr\u00fac c\u1ee7a m\u1ed9t recipes nh\u01b0 sau: vux-iperf/ \u251c\u2500\u2500 files \u2502 \u251c\u2500\u2500 0002-Remove-pg-from-profile_CFLAGS.patch \u2502 \u2514\u2500\u2500 automake-foreign.patch \u251c\u2500\u2500 README \u2514\u2500\u2500 vux-iperf.bb Trong v\u00ed d\u1ee5 l\u00e0 c\u1ea5u h\u00ecnh \u0111\u1ec3 build b\u1ea3n ph\u1ea7n m\u1ec1m iperf3. Bitbake file cho recipes n\u00e0y \u0111\u01b0\u1ee3c t\u1ea3i t\u1ea1i iperf3 3.6 (layers.openembedded.org). Trong file vux-iperf.bb c\u00f3 m\u1ed9t s\u1ed1 kh\u00e1i ni\u1ec7m v\u00e0 th\u00f4ng tin c\u1ea7n l\u01b0u \u00fd nh\u01b0 sau. \u0110\u01b0\u1eddng d\u1eabn \u0111\u1ebfn source code c\u1ee7a package Tham s\u1ed1 SRC_URI ch\u1ee9a \u0111\u01b0\u1eddng d\u1eabn \u0111\u1ebfn source code c\u1ee7a pakcage. Th\u00f4ng qua th\u00f4ng tin ch\u1ee9a trong \u0111\u01b0\u1eddng d\u1eabn n\u00e0y, bitbake th\u1ef1c hi\u1ec7n nhi\u1ec7m v\u1ee5 do_fetch. SRC_URI = \"git://github.com/esnet/iperf.git \\ file://automake-foreign.patch \\ Trong v\u00ed d\u1ee5 n\u00e0y, SRC_URI ch\u1ec9 \u0111\u1ebfn m\u1ed9t git repository c\u1ee7a esnet. Ng\u01b0\u1eddi d\u00f9ng c\u00f3 th\u1ec3 truy c\u1eadp tr\u1ef1c ti\u1ebfp v\u00e0o repo n\u00e0y \u0111\u1ec3 xem source code. Ngo\u00e0i ra SRC_URI ch\u1ec9 \u0111\u1ebfn m\u1ed9t file \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef local ch\u1ee9a b\u1ea3n patch. B\u1ea3n patch n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u00ecm th\u1ea5y tr\u00ean openembedded.org. Revision c\u1ee7a source code Tham s\u1ed1 SRCREV ch\u1ec9 cho bitbake bi\u1ebft \u0111\u01b0\u1ee3c revision n\u00e0o c\u1ee7a source code c\u1ea7n \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 build package. SRCREV = \"88d907f7fb58bfab5d086c5da60c922e1c582c92\" Ngo\u00e0i ra, SRCREV c\u00f2n c\u00f3 th\u1ec3 cung c\u1ea5p th\u00eam c\u00e1c th\u00f4ng tin nh\u01b0 sau: protocol: giao th\u1ee9c s\u1eed d\u1ee5ng \u0111\u1ec3 fetch source code (protocol=https...) branch: branch mong mu\u1ed1n fetch source code (branch=master...) T\u01b0\u01a1ng \u1ee9ng v\u1edbi m\u1ed7i revision ch\u1ee9a m\u1ed9t file LICENSE \u0111i k\u00e8m v\u1edbi MD5SUM. LIC_FILES_CHKSUM = \"file://LICENSE;md5=d098223e44bdd19585315ee75cd9d2d7\" L\u01b0u \u00fd r\u1eb1ng LIC_FILES c\u00f3 th\u1ec3 l\u00e0 LICENSE ho\u1eb7c b\u1ea5t c\u1ee9 t\u00ean kh\u00e1c.","title":"Add user custom package"},{"location":"lnx_es/yocto/","text":"Bitbake process Refer in 4.3.5 Yocto overview manual Source Fetching, Patching do_fetch - do_unpack - do_patch Configuration, Compilation, and Staging do_configure - do_compile - do_install do_install Copy file from B (Build?) dir to D (Destination dir) dir. Package Splitting do_package, do_packagedata, do_populate_sysroot Image Generation do_rootfs SDK Generation","title":"Yocto"},{"location":"lnx_es/yocto/#bitbake-process","text":"Refer in 4.3.5 Yocto overview manual","title":"Bitbake process"},{"location":"lnx_es/yocto/#source-fetching-patching","text":"do_fetch - do_unpack - do_patch","title":"Source Fetching, Patching"},{"location":"lnx_es/yocto/#configuration-compilation-and-staging","text":"do_configure - do_compile - do_install do_install Copy file from B (Build?) dir to D (Destination dir) dir.","title":"Configuration, Compilation, and Staging"},{"location":"lnx_es/yocto/#package-splitting","text":"do_package, do_packagedata, do_populate_sysroot","title":"Package Splitting"},{"location":"lnx_es/yocto/#image-generation","text":"do_rootfs","title":"Image Generation"},{"location":"lnx_es/yocto/#sdk-generation","text":"","title":"SDK Generation"},{"location":"projects/zc706/","text":"ZC706 This note is for zedboard","title":"ZC706"},{"location":"projects/zc706/#zc706","text":"This note is for zedboard","title":"ZC706"},{"location":"projects/zedboard/zedboard/","text":"Zedboard About ZedBoard ZedBoard\u2122 is a complete development kit for designers interested in exploring designs using the Xilinx Zynq\u00ae-7000 All Programmable SoC . Boot from SD Card with ext4 filesystem Origin Note T\u00e0i li\u1ec7u n\u00e0y m\u00f4 t\u1ea3 c\u00e1c kh\u1edfi \u0111\u1ed9ng Zed t\u1eeb SD card v\u1edbi rootfs \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef tr\u00ean m\u1ed9t ph\u00e2n v\u00f9ng \u0111\u1ecbnh d\u1ea1ng ext4. Ph\u01b0\u01a1ng ph\u00e1p n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho c\u00e1c board zynq kh\u00e1c nh\u01b0 ZC706, PicoZed. Chu\u1ea9n b\u1ecb images Trong t\u00e0i li\u1ec7u UG1144 c\u00f3 h\u01b0\u1edbng d\u1eabn qu\u00e1 tr\u00ecnh c\u1ea5u h\u00ecnh \u0111\u1ec3 c\u00f3 th\u1ec3 kh\u1edfi \u0111\u1ed9ng Zynq7000 t\u1eeb SD Card. Trong h\u01b0\u1edbng d\u1eabn n\u00e0y c\u1ea7n l\u01b0u \u00fd \u0111\u1ebfn 2 \u0111i\u1ec3m sau: Thi\u1ebft l\u1eadp petalinux project \u0111\u1ec3 c\u00e1c image \u0111\u01b0\u1ee3c package d\u01b0\u1edbi d\u1ea1ng c\u00f3 th\u1ec3 boot \u0111\u01b0\u1ee3c t\u1eeb SD Card. petalinux-config T\u1ea1o file rootfs.cpio b\u1eb1ng m\u00e3 l\u1ec7nh sau petalinux-package \\--image -c rootfs \\--format initramfs N\u1ebfu s\u1eed d\u1ee5ng l\u1ec7nh package \u0111\u1ec3 t\u1ea1o rootfs.cpio xu\u1ea5t hi\u1ec7n l\u1ed7i sau: [INFO ] package rootfs.cpio to /tmp/petalinux/images/linux ERROR: Linux kernel gen_init_cpio /tmp/petalinux/build/linux/kernel/usr/gen_init_cpio doesn\\'t exits! Please build Linux kernel first! make[1]: *** [package-rootfs-cpio] Fehler 255 make: *** [package-rootfs-initramfs] Fehler 2 ERROR: Failed to package component linux/rootfs *** Need to use extention to emphasize error notes, see in Mkdocs Tool Trong di\u1ec5n \u0111\u00e0n c\u1ee7a Xilinx ( link ) c\u00f3 th\u1ea3o lu\u1eadn v\u1ec1 ph\u01b0\u01a1ng ph\u00e1p \u0111\u1ec3 kh\u1eafc ph\u1ee5c \u0111\u01b0\u1ee3c l\u1ed7i tr\u00ean. Bao g\u1ed3m c\u00e1c b\u01b0\u1edbc x\u1eed l\u00fd nh\u01b0 sau: T\u1eaft ch\u1ebf \u0111\u1ed9 automatic kernel configuration petalinux-config Image Packaging Configuration ---> Root filesystem type = SD card Auto Config Settings ---> [ ] kernel autoconfig B\u1eadt ch\u1ebf \u0111\u1ed9 h\u1ed7 tr\u1ecd INITRAMFS trong c\u1ea5u h\u00ecnh c\u1ee7a kernel $ petalinux-config -c kernel General setup - [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support () Initramfs source file(s) Kernel Args Kernel Args b\u00ean trong device-tree ch\u1ee9a m\u1ed9t s\u1ed1 th\u00f4ng tin \u0111\u1ec3 kernel c\u00f3 th\u1ec3 t\u00ecm ki\u1ebfm \u0111\u01b0\u1ee3c ch\u00ednh x\u00e1c root filesystem c\u1ea7n \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho h\u1ec7 th\u1ed1ng. \u0110\u1ec3 kernel c\u00f3 th\u1ec3 t\u00ecm \u0111\u1ebfn \u0111\u01b0\u1ee3c ph\u00e2n v\u00f9ng rootfs tr\u00ean SD card v\u1eeba \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o c\u1ea7n thi\u1ebft l\u1eadp kernel args nh\u01b0 sau: bootargs = \"console=ttyPS0,115200 earlyprint root=/dev/mmcblk0p2 rw rootwait\"; Khi kh\u1edfi \u0111\u1ed9ng, kernel s\u1ebd t\u00ecm \u0111\u1ebfn ph\u00e2n v\u00f9ng /dev/mmcblk0p2 \u0111\u1ec3 mounting rootfs, sau \u0111\u00f3 kh\u1edfi \u0111\u1ed9ng ti\u1ebfn tr\u00ecnh init . Do trong kernel args kh\u00f4ng khai b\u00e1o \u0111\u1ecbnh d\u1ea1ng c\u1ee7a ph\u00e2n v\u00f9ng rootfs n\u00e0y n\u00ean kernel s\u1ebd ti\u1ebfn h\u00e0nh th\u1eed mounting ph\u00e2n v\u00f9ng v\u1edbi c\u00e1c \u0111\u1ecbnh d\u1ea1ng kh\u00e1c nhau v\u00e0 t\u00ecm ki\u1ebfm \u0111\u1ebfn \u0111\u1ecbnh d\u1ea1ng ph\u00f9 h\u1ee3p (\u1edf \u0111\u00e2y l\u00e0 ext4 ). T\u00ecm hi\u1ec3u th\u00eam th\u00f4ng tin v\u1ec1 c\u00e1c tham s\u1ed1 trong c\u1ea5u h\u00ecnh tr\u00ean \u1edf chuy\u00ean m\u1ee5c t\u00ecm hi\u1ec3u v\u1ec1 Kernel Args. Ph\u00e2n v\u00f9ng cho SD card C\u1ea7n chu\u1ea9n b\u1ecb SD Card v\u1edbi 02 ph\u00e2n v\u00f9ng: BOOT: \u0111\u01b0\u1ee3c format \u1edf \u0111\u1ecbnh d\u1ea1ng FAT32 ch\u1ee9a BOOT.BIN (bao g\u1ed3m FBSL, PL Bitstream, U-boot) v\u00e0 image.ub (Linux kernel v\u00e0 Device Tree). rootfs: \u0111\u01b0\u1ee3c format \u1edf \u0111\u1ecbnh d\u1ea1ng ext4 ch\u1ee9a root filesystem. Qu\u00e1 tr\u00ecnh chu\u1ea9n b\u1ecb ph\u00e2n v\u00f9ng tr\u00ean SD Card n\u00e0y s\u1ebd \u0111\u01b0\u1ee3c ti\u1ebfn h\u00e0nh \u0111\u01a1n gi\u1ea3n b\u1eb1ng c\u00e1c GUI Tool nh\u01b0 GParted . Ngo\u00e0i ra c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng t\u1ed5 h\u1ee3p CLI tool: fdisk mkfs.vfat mkfs.ext4. Ph\u01b0\u01a1ng ph\u00e1p s\u1eed d\u1ee5ng b\u1ed9 c\u00f4ng c\u1ee5 n\u00e0y \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 chi ti\u1ebft trong Wikipedia c\u1ee7a Xilinx. K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh ph\u00e2n v\u00f9ng v\u00e0 format n\u00e0y nh\u01b0 sau: Figure. SD Card Partitions C\u00e0i \u0111\u1eb7t boot image v\u00e0 rootfs l\u00ean SD card K\u1ebft qu\u1ea3 sau khi th\u1ef1c hi\u1ec7n xong c\u00e1c b\u01b0\u1edbc chu\u1ea9n b\u1ecb li\u00ean quan \u0111\u1ebfn images v\u00e0 SD Card: C\u00e1c file images: BOOT.BIN, image.ub v\u00e0 rootfs.cpio SD Card v\u1edbi hai ph\u00e2n v\u00f9ng: BOOT v\u00e0 rootfs. C\u00e1c images v\u00e0 filesystem ph\u1ea3i \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t l\u00ean SD Card tr\u01b0\u1edbc khi board c\u00f3 th\u1ec3 kh\u1edfi \u0111\u1ed9ng \u0111\u01b0\u1ee3c t\u1eeb SD Card. Bootloader Kernel Qu\u00e1 tr\u00ecnh c\u00e0i \u0111\u1eb7t bootloader v\u00e0 Linux kernel l\u00e0 qu\u00e1 tr\u00ecnh copy BOOT.BIN v\u00e0 image.ub l\u00ean ph\u00e2n v\u00f9ng BOOT c\u1ee7a sdcard. BootROM c\u1ee7a zynq \u0111\u1ee7 m\u1ea1nh \u0111\u1ec3 c\u00f3 th\u1ec3 t\u00ecm ki\u1ebfm \u0111\u01b0\u1ee3c zynq_fsbl.elf tr\u00ean ph\u00e2n v\u00f9ng \u0111\u1ecbnh d\u1ea1ng FAT32 \u0111\u1ec3 kh\u1edfi \u0111\u1ed9ng. Rootfs Ri\u00eang rootfs \u0111ang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i \u1edf file rootfs.cpio. S\u1eed d\u1ee5ng \u1ee9ng d\u1ee5ng pax \u0111\u1ec3 th\u00e1o d\u1ee1 filesystem \u0111ang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i \u1edf \u0111\u1ecbnh d\u1ea1ng cpio. cp images/linux/rootfs.cpio /media/rootfs/ cd /media/rootfs sudo pax -rvf rootfs.cpio Ngo\u00e0i ra, rootfs.cpio c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c th\u00e1o d\u1ee1 b\u1eb1ng m\u00e3 l\u1ec7nh cpio . Trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p h\u1ec7 nh\u00fang kh\u00f4ng t\u00edch h\u1ee3p s\u1eb5n g\u00f3i pax , cpio s\u1ebd l\u00e0 m\u1ed9t thay th\u1ebf c\u1ea7n thi\u1ebft. C\u00fa ph\u00e1p nh\u01b0 sau: cpio -i -F rootfs.cpio Ph\u00e2n t\u00edch v\u00e0 k\u1ebft lu\u1eadn Trong qu\u00e1 tr\u00ecnh chu\u1ea9n b\u1ecb SD Card xu\u1ea5t hi\u1ec7n c\u00e1c thu\u1eadt ng\u1eef. Trong m\u1ee5c n\u00e0y s\u1ebd \u0111i ph\u00e2n t\u00edch v\u00e0 gi\u1ea3i th\u00edch c\u00e1c thu\u1eadt ng\u1eef \u0111\u00f3. CPIO Trong h\u1ec7 \u0111i\u1ec1u h\u00e0nh Linux xu\u1ea5t hi\u1ec7n kh\u00e1i ni\u1ec7m archive (/\u02c8\u0251\u02d0ka\u026av/) file , l\u00e0 k\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh \u0111\u00f3ng g\u00f3i nhi\u1ec1u file d\u1eef li\u1ec7u th\u00e0nh m\u1ed9t file th\u1ed1ng nh\u1ea5t (kh\u00f4ng c\u00f3 qu\u00e1 tr\u00ecnh n\u00e9n d\u1eef li\u1ec7u). M\u1ee5c \u0111\u00edch c\u1ee7a qu\u00e1 tr\u00ecnh \u0111\u00f3ng g\u00f3i n\u00e0y l\u00e0 d\u1ec5 d\u00e0ng cho qu\u00e1 tr\u00ecnh l\u01b0u tr\u1eef c\u0169ng nh\u01b0 trao \u0111\u1ed5i d\u1eef li\u1ec7u. Archive file c\u0169ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng l\u00e0m \u0111\u1ea7u v\u00e0o cho c\u00e1c tr\u00ecnh n\u00e9n d\u1eef li\u1ec7u. Archive file \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i b\u1eb1ng c\u00e1c file archiver. Trong Unix-like system, c\u00e1c file archiver ph\u1ed5 bi\u1ebfn nh\u01b0: tar, ar, cpio. Rootfs k\u1ebft qu\u1ea3 c\u1ee7a b\u01b0\u1edbc 1 \u0111ang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i d\u01b0\u1edbi d\u1ea1ng archive file - cpio. Qu\u00e1 tr\u00ecnh c\u00e0i \u0111\u1eb7t rootfs l\u00ean ph\u00e2n v\u00f9ng rootfs tr\u00ean SD Card b\u1ea3n ch\u1ea5t l\u00e0 qu\u00e1 tr\u00ecnh th\u00e1o d\u1ee1 c\u00e1c archive file tr\u1edf v\u1ec1 c\u00e1c file ph\u00e2n bi\u1ec7t ban \u0111\u1ea7u. Qu\u00e1 tr\u00ecnh extract n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n b\u1edfi c\u00e1c Linux tool nh\u01b0: cpio ho\u1eb7c pax. Trong h\u01b0\u1edbng d\u1eabn c\u1ee7a Xilinx s\u1eed d\u1ee5ng pax \u0111\u1ec3 th\u00e1o d\u1ee1 rootfs. Fs format: fat32 v\u00e0 ext4. File system l\u00e0 c\u00e1ch m\u00e0 m\u1ed9t h\u1ec7 th\u1ed1ng file \u0111\u01b0\u1ee3c t\u1ed5 ch\u1ee9c tr\u00ean c\u00e1c b\u1ed9 nh\u1edb l\u01b0u tr\u1eef. C\u00e1c b\u1ed9 nh\u1edb l\u01b0u tr\u1eef c\u00f3 th\u1ec3 l\u00e0: disk file system ho\u1eb7c flash file system . Fat32 v\u00e0 ext4 l\u00e0 t\u00ean c\u1ee7a c\u00e1c d\u1ea1ng file system \u0111\u01b0\u1ee3c t\u1ed5 ch\u1ee9c ph\u1ed5 bi\u1ebfn tr\u00ean c\u00e1c d\u00f2ng disk file system nh\u01b0 SD Card trong b\u00e0i vi\u1ebft n\u00e0y l\u00e0 m\u1ed9t v\u00ed d\u1ee5. Ngo\u00e0i ra trong qu\u00e1 tr\u00ecnh l\u00e0m vi\u1ec7c v\u1edbi Rootfs c\u1ee7a zynq c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng \u0111\u1ebfn JFFS2 format l\u00e0 m\u1ed9t \u0111\u1ecbnh d\u1ea1ng file system s\u1eed d\u1ee5ng cho c\u00e1c b\u1ed9 nh\u1edb flash.","title":"Zedboard"},{"location":"projects/zedboard/zedboard/#zedboard","text":"","title":"Zedboard"},{"location":"projects/zedboard/zedboard/#about-zedboard","text":"ZedBoard\u2122 is a complete development kit for designers interested in exploring designs using the Xilinx Zynq\u00ae-7000 All Programmable SoC .","title":"About ZedBoard"},{"location":"projects/zedboard/zedboard/#boot-from-sd-card-with-ext4-filesystem","text":"Origin Note T\u00e0i li\u1ec7u n\u00e0y m\u00f4 t\u1ea3 c\u00e1c kh\u1edfi \u0111\u1ed9ng Zed t\u1eeb SD card v\u1edbi rootfs \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef tr\u00ean m\u1ed9t ph\u00e2n v\u00f9ng \u0111\u1ecbnh d\u1ea1ng ext4. Ph\u01b0\u01a1ng ph\u00e1p n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho c\u00e1c board zynq kh\u00e1c nh\u01b0 ZC706, PicoZed.","title":"Boot from SD Card with ext4 filesystem"},{"location":"projects/zedboard/zedboard/#chuan-bi-images","text":"Trong t\u00e0i li\u1ec7u UG1144 c\u00f3 h\u01b0\u1edbng d\u1eabn qu\u00e1 tr\u00ecnh c\u1ea5u h\u00ecnh \u0111\u1ec3 c\u00f3 th\u1ec3 kh\u1edfi \u0111\u1ed9ng Zynq7000 t\u1eeb SD Card. Trong h\u01b0\u1edbng d\u1eabn n\u00e0y c\u1ea7n l\u01b0u \u00fd \u0111\u1ebfn 2 \u0111i\u1ec3m sau: Thi\u1ebft l\u1eadp petalinux project \u0111\u1ec3 c\u00e1c image \u0111\u01b0\u1ee3c package d\u01b0\u1edbi d\u1ea1ng c\u00f3 th\u1ec3 boot \u0111\u01b0\u1ee3c t\u1eeb SD Card. petalinux-config T\u1ea1o file rootfs.cpio b\u1eb1ng m\u00e3 l\u1ec7nh sau petalinux-package \\--image -c rootfs \\--format initramfs N\u1ebfu s\u1eed d\u1ee5ng l\u1ec7nh package \u0111\u1ec3 t\u1ea1o rootfs.cpio xu\u1ea5t hi\u1ec7n l\u1ed7i sau: [INFO ] package rootfs.cpio to /tmp/petalinux/images/linux ERROR: Linux kernel gen_init_cpio /tmp/petalinux/build/linux/kernel/usr/gen_init_cpio doesn\\'t exits! Please build Linux kernel first! make[1]: *** [package-rootfs-cpio] Fehler 255 make: *** [package-rootfs-initramfs] Fehler 2 ERROR: Failed to package component linux/rootfs *** Need to use extention to emphasize error notes, see in Mkdocs Tool Trong di\u1ec5n \u0111\u00e0n c\u1ee7a Xilinx ( link ) c\u00f3 th\u1ea3o lu\u1eadn v\u1ec1 ph\u01b0\u01a1ng ph\u00e1p \u0111\u1ec3 kh\u1eafc ph\u1ee5c \u0111\u01b0\u1ee3c l\u1ed7i tr\u00ean. Bao g\u1ed3m c\u00e1c b\u01b0\u1edbc x\u1eed l\u00fd nh\u01b0 sau: T\u1eaft ch\u1ebf \u0111\u1ed9 automatic kernel configuration petalinux-config Image Packaging Configuration ---> Root filesystem type = SD card Auto Config Settings ---> [ ] kernel autoconfig B\u1eadt ch\u1ebf \u0111\u1ed9 h\u1ed7 tr\u1ecd INITRAMFS trong c\u1ea5u h\u00ecnh c\u1ee7a kernel $ petalinux-config -c kernel General setup - [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support () Initramfs source file(s)","title":"Chu\u1ea9n b\u1ecb images"},{"location":"projects/zedboard/zedboard/#kernel-args","text":"Kernel Args b\u00ean trong device-tree ch\u1ee9a m\u1ed9t s\u1ed1 th\u00f4ng tin \u0111\u1ec3 kernel c\u00f3 th\u1ec3 t\u00ecm ki\u1ebfm \u0111\u01b0\u1ee3c ch\u00ednh x\u00e1c root filesystem c\u1ea7n \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng cho h\u1ec7 th\u1ed1ng. \u0110\u1ec3 kernel c\u00f3 th\u1ec3 t\u00ecm \u0111\u1ebfn \u0111\u01b0\u1ee3c ph\u00e2n v\u00f9ng rootfs tr\u00ean SD card v\u1eeba \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o c\u1ea7n thi\u1ebft l\u1eadp kernel args nh\u01b0 sau: bootargs = \"console=ttyPS0,115200 earlyprint root=/dev/mmcblk0p2 rw rootwait\"; Khi kh\u1edfi \u0111\u1ed9ng, kernel s\u1ebd t\u00ecm \u0111\u1ebfn ph\u00e2n v\u00f9ng /dev/mmcblk0p2 \u0111\u1ec3 mounting rootfs, sau \u0111\u00f3 kh\u1edfi \u0111\u1ed9ng ti\u1ebfn tr\u00ecnh init . Do trong kernel args kh\u00f4ng khai b\u00e1o \u0111\u1ecbnh d\u1ea1ng c\u1ee7a ph\u00e2n v\u00f9ng rootfs n\u00e0y n\u00ean kernel s\u1ebd ti\u1ebfn h\u00e0nh th\u1eed mounting ph\u00e2n v\u00f9ng v\u1edbi c\u00e1c \u0111\u1ecbnh d\u1ea1ng kh\u00e1c nhau v\u00e0 t\u00ecm ki\u1ebfm \u0111\u1ebfn \u0111\u1ecbnh d\u1ea1ng ph\u00f9 h\u1ee3p (\u1edf \u0111\u00e2y l\u00e0 ext4 ). T\u00ecm hi\u1ec3u th\u00eam th\u00f4ng tin v\u1ec1 c\u00e1c tham s\u1ed1 trong c\u1ea5u h\u00ecnh tr\u00ean \u1edf chuy\u00ean m\u1ee5c t\u00ecm hi\u1ec3u v\u1ec1 Kernel Args.","title":"Kernel Args"},{"location":"projects/zedboard/zedboard/#phan-vung-cho-sd-card","text":"C\u1ea7n chu\u1ea9n b\u1ecb SD Card v\u1edbi 02 ph\u00e2n v\u00f9ng: BOOT: \u0111\u01b0\u1ee3c format \u1edf \u0111\u1ecbnh d\u1ea1ng FAT32 ch\u1ee9a BOOT.BIN (bao g\u1ed3m FBSL, PL Bitstream, U-boot) v\u00e0 image.ub (Linux kernel v\u00e0 Device Tree). rootfs: \u0111\u01b0\u1ee3c format \u1edf \u0111\u1ecbnh d\u1ea1ng ext4 ch\u1ee9a root filesystem. Qu\u00e1 tr\u00ecnh chu\u1ea9n b\u1ecb ph\u00e2n v\u00f9ng tr\u00ean SD Card n\u00e0y s\u1ebd \u0111\u01b0\u1ee3c ti\u1ebfn h\u00e0nh \u0111\u01a1n gi\u1ea3n b\u1eb1ng c\u00e1c GUI Tool nh\u01b0 GParted . Ngo\u00e0i ra c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng t\u1ed5 h\u1ee3p CLI tool: fdisk mkfs.vfat mkfs.ext4. Ph\u01b0\u01a1ng ph\u00e1p s\u1eed d\u1ee5ng b\u1ed9 c\u00f4ng c\u1ee5 n\u00e0y \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 chi ti\u1ebft trong Wikipedia c\u1ee7a Xilinx. K\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh ph\u00e2n v\u00f9ng v\u00e0 format n\u00e0y nh\u01b0 sau: Figure. SD Card Partitions","title":"Ph\u00e2n v\u00f9ng cho SD card"},{"location":"projects/zedboard/zedboard/#cai-at-boot-image-va-rootfs-len-sd-card","text":"K\u1ebft qu\u1ea3 sau khi th\u1ef1c hi\u1ec7n xong c\u00e1c b\u01b0\u1edbc chu\u1ea9n b\u1ecb li\u00ean quan \u0111\u1ebfn images v\u00e0 SD Card: C\u00e1c file images: BOOT.BIN, image.ub v\u00e0 rootfs.cpio SD Card v\u1edbi hai ph\u00e2n v\u00f9ng: BOOT v\u00e0 rootfs. C\u00e1c images v\u00e0 filesystem ph\u1ea3i \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t l\u00ean SD Card tr\u01b0\u1edbc khi board c\u00f3 th\u1ec3 kh\u1edfi \u0111\u1ed9ng \u0111\u01b0\u1ee3c t\u1eeb SD Card. Bootloader Kernel Qu\u00e1 tr\u00ecnh c\u00e0i \u0111\u1eb7t bootloader v\u00e0 Linux kernel l\u00e0 qu\u00e1 tr\u00ecnh copy BOOT.BIN v\u00e0 image.ub l\u00ean ph\u00e2n v\u00f9ng BOOT c\u1ee7a sdcard. BootROM c\u1ee7a zynq \u0111\u1ee7 m\u1ea1nh \u0111\u1ec3 c\u00f3 th\u1ec3 t\u00ecm ki\u1ebfm \u0111\u01b0\u1ee3c zynq_fsbl.elf tr\u00ean ph\u00e2n v\u00f9ng \u0111\u1ecbnh d\u1ea1ng FAT32 \u0111\u1ec3 kh\u1edfi \u0111\u1ed9ng. Rootfs Ri\u00eang rootfs \u0111ang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i \u1edf file rootfs.cpio. S\u1eed d\u1ee5ng \u1ee9ng d\u1ee5ng pax \u0111\u1ec3 th\u00e1o d\u1ee1 filesystem \u0111ang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i \u1edf \u0111\u1ecbnh d\u1ea1ng cpio. cp images/linux/rootfs.cpio /media/rootfs/ cd /media/rootfs sudo pax -rvf rootfs.cpio Ngo\u00e0i ra, rootfs.cpio c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c th\u00e1o d\u1ee1 b\u1eb1ng m\u00e3 l\u1ec7nh cpio . Trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p h\u1ec7 nh\u00fang kh\u00f4ng t\u00edch h\u1ee3p s\u1eb5n g\u00f3i pax , cpio s\u1ebd l\u00e0 m\u1ed9t thay th\u1ebf c\u1ea7n thi\u1ebft. C\u00fa ph\u00e1p nh\u01b0 sau: cpio -i -F rootfs.cpio","title":"C\u00e0i \u0111\u1eb7t boot image v\u00e0 rootfs l\u00ean SD card"},{"location":"projects/zedboard/zedboard/#phan-tich-va-ket-luan","text":"Trong qu\u00e1 tr\u00ecnh chu\u1ea9n b\u1ecb SD Card xu\u1ea5t hi\u1ec7n c\u00e1c thu\u1eadt ng\u1eef. Trong m\u1ee5c n\u00e0y s\u1ebd \u0111i ph\u00e2n t\u00edch v\u00e0 gi\u1ea3i th\u00edch c\u00e1c thu\u1eadt ng\u1eef \u0111\u00f3.","title":"Ph\u00e2n t\u00edch v\u00e0 k\u1ebft lu\u1eadn"},{"location":"projects/zedboard/zedboard/#cpio","text":"Trong h\u1ec7 \u0111i\u1ec1u h\u00e0nh Linux xu\u1ea5t hi\u1ec7n kh\u00e1i ni\u1ec7m archive (/\u02c8\u0251\u02d0ka\u026av/) file , l\u00e0 k\u1ebft qu\u1ea3 c\u1ee7a qu\u00e1 tr\u00ecnh \u0111\u00f3ng g\u00f3i nhi\u1ec1u file d\u1eef li\u1ec7u th\u00e0nh m\u1ed9t file th\u1ed1ng nh\u1ea5t (kh\u00f4ng c\u00f3 qu\u00e1 tr\u00ecnh n\u00e9n d\u1eef li\u1ec7u). M\u1ee5c \u0111\u00edch c\u1ee7a qu\u00e1 tr\u00ecnh \u0111\u00f3ng g\u00f3i n\u00e0y l\u00e0 d\u1ec5 d\u00e0ng cho qu\u00e1 tr\u00ecnh l\u01b0u tr\u1eef c\u0169ng nh\u01b0 trao \u0111\u1ed5i d\u1eef li\u1ec7u. Archive file c\u0169ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng l\u00e0m \u0111\u1ea7u v\u00e0o cho c\u00e1c tr\u00ecnh n\u00e9n d\u1eef li\u1ec7u. Archive file \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i b\u1eb1ng c\u00e1c file archiver. Trong Unix-like system, c\u00e1c file archiver ph\u1ed5 bi\u1ebfn nh\u01b0: tar, ar, cpio. Rootfs k\u1ebft qu\u1ea3 c\u1ee7a b\u01b0\u1edbc 1 \u0111ang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i d\u01b0\u1edbi d\u1ea1ng archive file - cpio. Qu\u00e1 tr\u00ecnh c\u00e0i \u0111\u1eb7t rootfs l\u00ean ph\u00e2n v\u00f9ng rootfs tr\u00ean SD Card b\u1ea3n ch\u1ea5t l\u00e0 qu\u00e1 tr\u00ecnh th\u00e1o d\u1ee1 c\u00e1c archive file tr\u1edf v\u1ec1 c\u00e1c file ph\u00e2n bi\u1ec7t ban \u0111\u1ea7u. Qu\u00e1 tr\u00ecnh extract n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n b\u1edfi c\u00e1c Linux tool nh\u01b0: cpio ho\u1eb7c pax. Trong h\u01b0\u1edbng d\u1eabn c\u1ee7a Xilinx s\u1eed d\u1ee5ng pax \u0111\u1ec3 th\u00e1o d\u1ee1 rootfs.","title":"CPIO"},{"location":"projects/zedboard/zedboard/#fs-format-fat32-va-ext4","text":"File system l\u00e0 c\u00e1ch m\u00e0 m\u1ed9t h\u1ec7 th\u1ed1ng file \u0111\u01b0\u1ee3c t\u1ed5 ch\u1ee9c tr\u00ean c\u00e1c b\u1ed9 nh\u1edb l\u01b0u tr\u1eef. C\u00e1c b\u1ed9 nh\u1edb l\u01b0u tr\u1eef c\u00f3 th\u1ec3 l\u00e0: disk file system ho\u1eb7c flash file system . Fat32 v\u00e0 ext4 l\u00e0 t\u00ean c\u1ee7a c\u00e1c d\u1ea1ng file system \u0111\u01b0\u1ee3c t\u1ed5 ch\u1ee9c ph\u1ed5 bi\u1ebfn tr\u00ean c\u00e1c d\u00f2ng disk file system nh\u01b0 SD Card trong b\u00e0i vi\u1ebft n\u00e0y l\u00e0 m\u1ed9t v\u00ed d\u1ee5. Ngo\u00e0i ra trong qu\u00e1 tr\u00ecnh l\u00e0m vi\u1ec7c v\u1edbi Rootfs c\u1ee7a zynq c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng \u0111\u1ebfn JFFS2 format l\u00e0 m\u1ed9t \u0111\u1ecbnh d\u1ea1ng file system s\u1eed d\u1ee5ng cho c\u00e1c b\u1ed9 nh\u1edb flash.","title":"Fs format: fat32 v\u00e0 ext4."},{"location":"technote/makefile/makefile/","text":"Make system in Linux Original Note T\u00e0i li\u1ec7u n\u00e0y m\u00f4 t\u1ea3 chung v\u1ec1 Makefile, trong \u0111\u00f3 nh\u1eafc \u0111\u1ebfn c\u00e1c kh\u00e1i ni\u1ec7m quan tr\u1ecdng \u0111\u1ec3 c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c c\u00e1c Makefile ph\u1ee9c t\u1ea1p. make Kh\u00e1i ni\u1ec7m \"make\" l\u00e0 m\u1ed9t \"build tool\" \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 g\u1ecdi \u0111\u1ebfn c\u00e1c th\u00e0nh ph\u1ea7n trong m\u1ed9t toolchain (nh\u01b0 compiler, linker) \u0111\u1ec3 build ra executable programs t\u1eeb source code. \"make\" t\u1ef1 \u0111\u1ed9ng ph\u00e1t hi\u1ec7n \u0111\u01b0\u1ee3c ph\u1ea7n n\u00e0o c\u1ee7a source code \u0111\u01b0\u1ee3c s\u1eeda \u0111\u1ed5i \u0111\u1ec3 ti\u1ebfn h\u00e0nh build l\u1ea1i c\u1ee5c b\u1ed9 t\u1eebng b\u1ed9 ph\u1eadn \u0111\u00f3. Tr\u00e1nh \u0111\u01b0\u1ee3c tr\u01b0\u1eddng h\u1ee3p ph\u1ea3i build l\u1ea1i to\u00e0n b\u1ed9 h\u1ec7 th\u1ed1ng khi ch\u1ec9 m\u1ed9t ph\u1ea7n \u0111\u01b0\u1ee3c thay \u0111\u1ed5i. \"make\" c\u1ea7n m\u1ed9t file \u0111\u1eb7c bi\u1ec7t \u0111\u1ec3 m\u00f4 t\u1ea3 c\u00e1c b\u01b0\u1edbc \u0111\u1ec3 build ra image, \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0: Makefile. Th\u00f4ng th\u01b0\u1eddng khi \u0111\u01b0\u1ee3c g\u1ecdi \u0111\u1ebfn, \"make\" s\u1ebd t\u00ecm ki\u1ebfm trong th\u01b0 m\u1ee5c hi\u1ec7n t\u1ea1i c\u00e1c t\u00ean file nh\u01b0 sau: makefile, Makefile ho\u1eb7c GNUmakefile. Trong tr\u01b0\u1eddng h\u1ee3p makefile kh\u00f4ng \u0111\u01b0\u1ee3c \u0111\u1eb7t theo chu\u1ea9n tr\u00ean, khai b\u00e1o makefile v\u1edbi \"make\" b\u1eb1ng ch\u1ec9 d\u1eabn \u2013f filename> ho\u1eb7c \u2013file= name>. Makefile Makefile l\u00e0 t\u1eadp h\u1ee3p c\u00e1c \u0111o\u1ea1n l\u1ec7nh m\u00f4 t\u1ea3 cho \"make\" bi\u1ebft ph\u1ea3i l\u00e0m g\u00ec \u0111\u1ec3 build ch\u01b0\u01a1ng tr\u00ecnh. C\u00e1c \u0111o\u1ea1n l\u1ec7nh m\u00f4 t\u1ea3 n\u00e0y \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 Rules. Rules M\u1ed9t Rules c\u00f3 d\u1ea1ng nh\u01b0 sau target \u2026 : prerequisites \u2026 recipe \u2026 \u2026 Target: th\u00f4ng th\u01b0\u1eddng l\u00e0 \u0111\u1ea7u ra (executable ho\u1eb7c object file) c\u1ee7a make. Ngo\u00e0i ra trong make \u0111\u1ecbnh ngh\u0129a th\u00eam m\u1ed9t lo\u1ea1i target \u0111\u1eb7c bi\u1ec7t: Phony Targets. M\u1ed9t target \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a out-of-date khi: Target \u0111\u00f3 kh\u00f4ng t\u1ed3n t\u1ea1i. C\u00e1c prerequisites b\u1ecb thay \u0111\u1ed5i. Implicit Rules \u0110\u1ec3 thu\u1eadn ti\u1ec7n cho ng\u01b0\u1eddi d\u00f9ng c\u0169ng nh\u01b0 l\u00e0m \u0111\u01a1n gi\u1ea3n Makefile, \"make\" \u0111\u1ecbnh ngh\u0129a c\u00e1c Implicit Rules . Trong m\u1ed9t s\u1ed1 Rules, n\u1ebfu recipe kh\u00f4ng \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a, \"make\" s\u1ebd th\u1ef1c hi\u1ec7n build theo m\u1ed9t s\u1ed1 lu\u1eadt ng\u1ea7m \u0111\u00e3 \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a tr\u01b0\u1edbc. V\u00ed d\u1ee5 nh\u01b0 khi rule c\u00f3 d\u1ea1ng main: main.c Ho\u1eb7c \u0111\u01a1n gi\u1ea3n h\u01a1n n\u1eefa main: Trong rule tr\u00ean kh\u00f4ng m\u00f4 t\u1ea3 recipe \u0111\u1ec3 \"make\" c\u00f3 th\u1ec3 ti\u1ebfn h\u00e0nh build, do \u0111\u00f3 \"make\" s\u1eed d\u1ee5ng implicit rule khi build v\u1edbi C source v\u00e0 s\u1ebd g\u1ecdi \u0111\u1ebfn: cc main.c \u2013o main Trong \u0111\u00f3 cc l\u00e0 system compiler. Variables Bi\u1ebfn (ho\u1eb7c c\u0169ng c\u00f3 th\u1ec3 g\u1ecdi l\u00e0 macro) \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong Makefile \u0111\u1ec3 \u0111\u1ea1i di\u1ec7n cho m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1. Trong Makefile c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng c\u00e1c Automatic Variables . $@: l\u00e0 target c\u1ee7a rules $ : l\u00e0 t\u00ean c\u1ee7a prerequisites $^: t\u00ean c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c prerequisites \u0111\u01b0\u1ee3c c\u00e1c nhau b\u1eb1ng d\u1ea5u c\u00e1ch tr\u1eafng.","title":"Makefile"},{"location":"technote/makefile/makefile/#make-system-in-linux","text":"Original Note T\u00e0i li\u1ec7u n\u00e0y m\u00f4 t\u1ea3 chung v\u1ec1 Makefile, trong \u0111\u00f3 nh\u1eafc \u0111\u1ebfn c\u00e1c kh\u00e1i ni\u1ec7m quan tr\u1ecdng \u0111\u1ec3 c\u00f3 th\u1ec3 \u0111\u1ecdc \u0111\u01b0\u1ee3c c\u00e1c Makefile ph\u1ee9c t\u1ea1p.","title":"Make system in Linux"},{"location":"technote/makefile/makefile/#make","text":"","title":"make"},{"location":"technote/makefile/makefile/#khai-niem","text":"\"make\" l\u00e0 m\u1ed9t \"build tool\" \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 g\u1ecdi \u0111\u1ebfn c\u00e1c th\u00e0nh ph\u1ea7n trong m\u1ed9t toolchain (nh\u01b0 compiler, linker) \u0111\u1ec3 build ra executable programs t\u1eeb source code. \"make\" t\u1ef1 \u0111\u1ed9ng ph\u00e1t hi\u1ec7n \u0111\u01b0\u1ee3c ph\u1ea7n n\u00e0o c\u1ee7a source code \u0111\u01b0\u1ee3c s\u1eeda \u0111\u1ed5i \u0111\u1ec3 ti\u1ebfn h\u00e0nh build l\u1ea1i c\u1ee5c b\u1ed9 t\u1eebng b\u1ed9 ph\u1eadn \u0111\u00f3. Tr\u00e1nh \u0111\u01b0\u1ee3c tr\u01b0\u1eddng h\u1ee3p ph\u1ea3i build l\u1ea1i to\u00e0n b\u1ed9 h\u1ec7 th\u1ed1ng khi ch\u1ec9 m\u1ed9t ph\u1ea7n \u0111\u01b0\u1ee3c thay \u0111\u1ed5i. \"make\" c\u1ea7n m\u1ed9t file \u0111\u1eb7c bi\u1ec7t \u0111\u1ec3 m\u00f4 t\u1ea3 c\u00e1c b\u01b0\u1edbc \u0111\u1ec3 build ra image, \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0: Makefile. Th\u00f4ng th\u01b0\u1eddng khi \u0111\u01b0\u1ee3c g\u1ecdi \u0111\u1ebfn, \"make\" s\u1ebd t\u00ecm ki\u1ebfm trong th\u01b0 m\u1ee5c hi\u1ec7n t\u1ea1i c\u00e1c t\u00ean file nh\u01b0 sau: makefile, Makefile ho\u1eb7c GNUmakefile. Trong tr\u01b0\u1eddng h\u1ee3p makefile kh\u00f4ng \u0111\u01b0\u1ee3c \u0111\u1eb7t theo chu\u1ea9n tr\u00ean, khai b\u00e1o makefile v\u1edbi \"make\" b\u1eb1ng ch\u1ec9 d\u1eabn \u2013f filename> ho\u1eb7c \u2013file= name>.","title":"Kh\u00e1i ni\u1ec7m"},{"location":"technote/makefile/makefile/#makefile","text":"Makefile l\u00e0 t\u1eadp h\u1ee3p c\u00e1c \u0111o\u1ea1n l\u1ec7nh m\u00f4 t\u1ea3 cho \"make\" bi\u1ebft ph\u1ea3i l\u00e0m g\u00ec \u0111\u1ec3 build ch\u01b0\u01a1ng tr\u00ecnh. C\u00e1c \u0111o\u1ea1n l\u1ec7nh m\u00f4 t\u1ea3 n\u00e0y \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 Rules.","title":"Makefile"},{"location":"technote/makefile/makefile/#rules","text":"M\u1ed9t Rules c\u00f3 d\u1ea1ng nh\u01b0 sau target \u2026 : prerequisites \u2026 recipe \u2026 \u2026 Target: th\u00f4ng th\u01b0\u1eddng l\u00e0 \u0111\u1ea7u ra (executable ho\u1eb7c object file) c\u1ee7a make. Ngo\u00e0i ra trong make \u0111\u1ecbnh ngh\u0129a th\u00eam m\u1ed9t lo\u1ea1i target \u0111\u1eb7c bi\u1ec7t: Phony Targets. M\u1ed9t target \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a out-of-date khi: Target \u0111\u00f3 kh\u00f4ng t\u1ed3n t\u1ea1i. C\u00e1c prerequisites b\u1ecb thay \u0111\u1ed5i.","title":"Rules"},{"location":"technote/makefile/makefile/#implicit-rules","text":"\u0110\u1ec3 thu\u1eadn ti\u1ec7n cho ng\u01b0\u1eddi d\u00f9ng c\u0169ng nh\u01b0 l\u00e0m \u0111\u01a1n gi\u1ea3n Makefile, \"make\" \u0111\u1ecbnh ngh\u0129a c\u00e1c Implicit Rules . Trong m\u1ed9t s\u1ed1 Rules, n\u1ebfu recipe kh\u00f4ng \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a, \"make\" s\u1ebd th\u1ef1c hi\u1ec7n build theo m\u1ed9t s\u1ed1 lu\u1eadt ng\u1ea7m \u0111\u00e3 \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a tr\u01b0\u1edbc. V\u00ed d\u1ee5 nh\u01b0 khi rule c\u00f3 d\u1ea1ng main: main.c Ho\u1eb7c \u0111\u01a1n gi\u1ea3n h\u01a1n n\u1eefa main: Trong rule tr\u00ean kh\u00f4ng m\u00f4 t\u1ea3 recipe \u0111\u1ec3 \"make\" c\u00f3 th\u1ec3 ti\u1ebfn h\u00e0nh build, do \u0111\u00f3 \"make\" s\u1eed d\u1ee5ng implicit rule khi build v\u1edbi C source v\u00e0 s\u1ebd g\u1ecdi \u0111\u1ebfn: cc main.c \u2013o main Trong \u0111\u00f3 cc l\u00e0 system compiler.","title":"Implicit Rules"},{"location":"technote/makefile/makefile/#variables","text":"Bi\u1ebfn (ho\u1eb7c c\u0169ng c\u00f3 th\u1ec3 g\u1ecdi l\u00e0 macro) \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a trong Makefile \u0111\u1ec3 \u0111\u1ea1i di\u1ec7n cho m\u1ed9t chu\u1ed7i k\u00fd t\u1ef1. Trong Makefile c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng c\u00e1c Automatic Variables . $@: l\u00e0 target c\u1ee7a rules $ : l\u00e0 t\u00ean c\u1ee7a prerequisites $^: t\u00ean c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c prerequisites \u0111\u01b0\u1ee3c c\u00e1c nhau b\u1eb1ng d\u1ea5u c\u00e1ch tr\u1eafng.","title":"Variables"},{"location":"technote/markdown/markdown/","text":"Markdown Language Markdown is used for writing this website. So, the first thing I need to learn is about Markdown Language. About Markdown Figure 1. Markdown icon lightweight markup language was created by John Gruber in 2004 Basic Syntax This section notes about Markdown basic syntax. Insert a picture in Markdown: ![picture_name](direction_to_picture) Insert a hyperlink: [Name](Link) . Hyperlink is used in References in this note. Colour for Text: (need to use HTML language) Red , Green , Blue , Yellow , Pink , Violet , Orange , Code and emphasize C syntax: int main() { printf( Hello world! ); return 0; } Quote (put ' ' before writing quote): This is example of block quote This is example of block quote Horizontal Rule: put a horizontal rule in doc by typing *** , see result below Task list (do not success by now) [x] Write the press release [ ] Update the website [ ] Contact the media Inserting a figure to docs: refer About Markdown in this page for example !!! note with \"admonition\" in mkdocs.yml add markdown_extensions: -admonition to mkdocs.yml file. Read more at Markdown Extentions Markdown Extentions Got information about markdown extentions at https://squidfunk.github.io/mkdocs-material/extensions/admonition/ PyMdown https://squidfunk.github.io/mkdocs-material/extensions/pymdown/ References The Markdown Guide - Matt Cone Markdown Guide - Website Basic writing and formatting syntax - GitHub Markdown Guide - Gitlab","title":"Markdown Language"},{"location":"technote/markdown/markdown/#markdown-language","text":"Markdown is used for writing this website. So, the first thing I need to learn is about Markdown Language.","title":"Markdown Language"},{"location":"technote/markdown/markdown/#about-markdown","text":"Figure 1. Markdown icon lightweight markup language was created by John Gruber in 2004","title":"About Markdown"},{"location":"technote/markdown/markdown/#basic-syntax","text":"This section notes about Markdown basic syntax. Insert a picture in Markdown: ![picture_name](direction_to_picture) Insert a hyperlink: [Name](Link) . Hyperlink is used in References in this note. Colour for Text: (need to use HTML language) Red , Green , Blue , Yellow , Pink , Violet , Orange , Code and emphasize C syntax: int main() { printf( Hello world! ); return 0; } Quote (put ' ' before writing quote): This is example of block quote This is example of block quote Horizontal Rule: put a horizontal rule in doc by typing *** , see result below Task list (do not success by now) [x] Write the press release [ ] Update the website [ ] Contact the media Inserting a figure to docs: refer About Markdown in this page for example !!! note with \"admonition\" in mkdocs.yml add markdown_extensions: -admonition to mkdocs.yml file. Read more at Markdown Extentions","title":"Basic Syntax"},{"location":"technote/markdown/markdown/#markdown-extentions","text":"Got information about markdown extentions at https://squidfunk.github.io/mkdocs-material/extensions/admonition/","title":"Markdown Extentions"},{"location":"technote/markdown/markdown/#pymdown","text":"https://squidfunk.github.io/mkdocs-material/extensions/pymdown/","title":"PyMdown"},{"location":"technote/markdown/markdown/#references","text":"The Markdown Guide - Matt Cone Markdown Guide - Website Basic writing and formatting syntax - GitHub Markdown Guide - Gitlab","title":"References"},{"location":"technote/mkdocs/mkdocs-notes/","text":"MkDocs documentation This technote is built by Mkdocs . MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown , and configured with a single YAML configuration file (see Project Layout ). More detail about this tool at MKdocs . Others popular static site generator site platform: Pelican (suggested by Nguy\u1ec5n \u0110\u0103ng S\u01a1n - ESRC K53) Sphinx (I have tried to use, but faced errors - not fixed yet when publishing in Github Page) Getting started mkdocs new [project name] - Create a new project Deploy in Github Page This document will be published in Github Page . To do this, you need: Create a repository in github with name: vutang.github.io Clone this repo to local machine In local machine, use command: mkdocs gh-deploy --remote-branch master --config-file [directory to mkdocs.yml] Test with local webserver use mkdocs serve to run local web server in your browser, access http://127.0.0.1:8000 Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Support Themes The list of supported themes for Mkdocs https://github.com/mkdocs/mkdocs/wiki/MkDocs-Themes Readthedocs: readthedocs Material: material Readthedocs-DropDown: rtd-dropdown - trying but not really successful by now, need to figure out what happens Material Material is a theme for MkDocs , an excellent static site generator geared towards project documentation. It is built using Google's Material Design guidelines. To install Material theme for Mkdocs: sudo pip install mkdocs-material . Folow instruction in here . References Mkdocs Wiki","title":"Mkdocs Tool"},{"location":"technote/mkdocs/mkdocs-notes/#mkdocs-documentation","text":"This technote is built by Mkdocs . MkDocs is a fast, simple and downright gorgeous static site generator that's geared towards building project documentation. Documentation source files are written in Markdown , and configured with a single YAML configuration file (see Project Layout ). More detail about this tool at MKdocs . Others popular static site generator site platform: Pelican (suggested by Nguy\u1ec5n \u0110\u0103ng S\u01a1n - ESRC K53) Sphinx (I have tried to use, but faced errors - not fixed yet when publishing in Github Page)","title":"MkDocs documentation"},{"location":"technote/mkdocs/mkdocs-notes/#getting-started","text":"mkdocs new [project name] - Create a new project","title":"Getting started"},{"location":"technote/mkdocs/mkdocs-notes/#deploy-in-github-page","text":"This document will be published in Github Page . To do this, you need: Create a repository in github with name: vutang.github.io Clone this repo to local machine In local machine, use command: mkdocs gh-deploy --remote-branch master --config-file [directory to mkdocs.yml]","title":"Deploy in Github Page"},{"location":"technote/mkdocs/mkdocs-notes/#test-with-local-webserver","text":"use mkdocs serve to run local web server in your browser, access http://127.0.0.1:8000","title":"Test with local webserver"},{"location":"technote/mkdocs/mkdocs-notes/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"technote/mkdocs/mkdocs-notes/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"technote/mkdocs/mkdocs-notes/#support-themes","text":"The list of supported themes for Mkdocs https://github.com/mkdocs/mkdocs/wiki/MkDocs-Themes Readthedocs: readthedocs Material: material Readthedocs-DropDown: rtd-dropdown - trying but not really successful by now, need to figure out what happens","title":"Support Themes"},{"location":"technote/mkdocs/mkdocs-notes/#material","text":"Material is a theme for MkDocs , an excellent static site generator geared towards project documentation. It is built using Google's Material Design guidelines. To install Material theme for Mkdocs: sudo pip install mkdocs-material . Folow instruction in here .","title":"Material"},{"location":"technote/mkdocs/mkdocs-notes/#references","text":"Mkdocs Wiki","title":"References"},{"location":"technote/python/python/","text":"Python Syntax print print( Total Revenue: %f % total_revenue) print( Total Revenue: ${f} .format(total_revenue)) List List comprehension cuts_under_30 = [hairstyles[i] for i in range(int(len(hairstyles))) if new_prices[i] 30] Get index of element in list list.index(element) Try except try: some_thing = can_trigger_a_syntax_errror() except SyntaxError: print( Error caught! )","title":"Python"},{"location":"technote/python/python/#python-syntax","text":"","title":"Python Syntax"},{"location":"technote/python/python/#print","text":"print( Total Revenue: %f % total_revenue) print( Total Revenue: ${f} .format(total_revenue))","title":"print"},{"location":"technote/python/python/#list","text":"List comprehension cuts_under_30 = [hairstyles[i] for i in range(int(len(hairstyles))) if new_prices[i] 30] Get index of element in list list.index(element)","title":"List"},{"location":"technote/python/python/#try-except","text":"try: some_thing = can_trigger_a_syntax_errror() except SyntaxError: print( Error caught! )","title":"Try &amp; except"},{"location":"technote/shellscript/shellscript/","text":"Shell Script References Shell Scripting Tutorial Syntax Array Handling array in shell script. rxPwr=(7 7 7) # declaring an array for i in 0 1 2 3 do rxPwr[$i]=$i # access element in array echo ${rxPwr[$i]} done Variable handle dpd_chan=$1 #Parsing value to variable from argument pa_chan=$((dpd_chan+1)) #Adding 1 Loop For for i in 0 1 2 3 do rxPwr[$i]=`dpdctl check $i | grep rx | awk {'print $4'}` printf %0.2f, ${rxPwr[$i]} $logdir done While while true; do # Do something here done Example: ADDR=0x43c40000 while [ $(($ADDR)) -lt $((0x43c00010)) ]; do VALUE=`peek $ADDR` printf 0x%08x\\t0x%08x\\n $ADDR $VALUE regdump.txt ADDR=$(($ADDR + 4)) done Condition state if [ $1 = all ]; then # Add code here fi Check if a file exist or not if [ -f $LOG_MON_FILE ]; then # Contents fi Print a string to output printf : print a string with format printf %0.2f, ${txCpl[$i]} $logdir printf 0x%08x $ADDR Passing Argurments $#: number of arguments $i: the i-th argument Operations Bitwise : , |, ~ a=0x1 b=0x2 c=$(($a | $b)) # or (two operands) c=$((($a | $b) $b)) # more than two operands c=$((~$a)) # not (only one operands) Shift : a=0x1 c=$(($a 2)) # shift left a 2 postition and then assign result to c Relational operators","title":"Shell Script"},{"location":"technote/shellscript/shellscript/#shell-script","text":"","title":"Shell Script"},{"location":"technote/shellscript/shellscript/#references","text":"Shell Scripting Tutorial","title":"References"},{"location":"technote/shellscript/shellscript/#syntax","text":"","title":"Syntax"},{"location":"technote/shellscript/shellscript/#array","text":"Handling array in shell script. rxPwr=(7 7 7) # declaring an array for i in 0 1 2 3 do rxPwr[$i]=$i # access element in array echo ${rxPwr[$i]} done","title":"Array"},{"location":"technote/shellscript/shellscript/#variable-handle","text":"dpd_chan=$1 #Parsing value to variable from argument pa_chan=$((dpd_chan+1)) #Adding 1","title":"Variable handle"},{"location":"technote/shellscript/shellscript/#loop","text":"For for i in 0 1 2 3 do rxPwr[$i]=`dpdctl check $i | grep rx | awk {'print $4'}` printf %0.2f, ${rxPwr[$i]} $logdir done While while true; do # Do something here done Example: ADDR=0x43c40000 while [ $(($ADDR)) -lt $((0x43c00010)) ]; do VALUE=`peek $ADDR` printf 0x%08x\\t0x%08x\\n $ADDR $VALUE regdump.txt ADDR=$(($ADDR + 4)) done","title":"Loop"},{"location":"technote/shellscript/shellscript/#condition-state","text":"if [ $1 = all ]; then # Add code here fi Check if a file exist or not if [ -f $LOG_MON_FILE ]; then # Contents fi","title":"Condition state"},{"location":"technote/shellscript/shellscript/#print-a-string-to-output","text":"printf : print a string with format printf %0.2f, ${txCpl[$i]} $logdir printf 0x%08x $ADDR","title":"Print a string to output"},{"location":"technote/shellscript/shellscript/#passing-argurments","text":"$#: number of arguments $i: the i-th argument","title":"Passing Argurments"},{"location":"technote/shellscript/shellscript/#operations","text":"Bitwise : , |, ~ a=0x1 b=0x2 c=$(($a | $b)) # or (two operands) c=$((($a | $b) $b)) # more than two operands c=$((~$a)) # not (only one operands) Shift : a=0x1 c=$(($a 2)) # shift left a 2 postition and then assign result to c Relational operators","title":"Operations"},{"location":"technote/tips/tips/","text":"SSH for remote control Secure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line login and remote command execution , but any network service can be secured with SSH. Advanced options Disable host key checking: ssh -o StrictHostKeyChecking=no Redirect known host file (~/.ssh/known_hosts) to /dev/null: ssh -o UserKnownHostsFile=/dev/null Execute scripts in remote machine: ssh user@host 'ENDSSH' #commands to run on remote host ENDSSH Example ssh root@10.61.61.195 \"echo 1 ~/test\" . This command will remote to root@10.61.61.195 machine and then execute \"echo 1 ~/test\" Auto-generate password for ssh echo #!/bin/sh /tmp/genpass.sh echo echo $pass /tmp/genpass.sh export SSH_ASKPASS= /tmp/genpass.sh export DISPLAY= setsid ssh root@10.61.61.195 ? setsid: what is this? See more at Bash Script SSH Automation Without a Password Prompt . Example commands timeout 20 setsid ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null References More information about SSH config can be found at https://linux.die.net/man/5/ssh_config TFTP Server Trivial File Transfer Protocol (TFTP) is a simple lockstep File Transfer Protocol which allows a client to get a file from or put a file onto a remote host ( Wiki ). TFTP uses UDP as its transport protocol. Install TFTP server With Ubuntu machine, install tftp by installing following packages: sudo apt-get install xinetd tftpd tftp Build tftp server for embedded system: How to build? Configure TFTP server Create /etc/xinetd.d/tftp and put this entry service tftp { protocol = udp port = 69 socket_type = dgram wait = yes user = nobody server = /usr/sbin/in.tftpd server_args = /tftpboot disable = no } Create a folder /tftpboot this should match whatever you gave in server_args. mostly it will be tftpboot sudo mkdir /tftpboot sudo chmod -R 777 /tftpboot sudo chown -R nobody /tftpboot Restart the xinetd service. newer systems: sudo service xinetd restart older systems: sudo /etc/init.d/xinetd restart Testing tftp server Create a file named test with some content in /tftpboot path of the tftp server. Obtain the ip address of the tftp server using ifconfig command. Now in some other system (client - which want to get file) follow the following steps. tftp 192.168.1.2 # tftp server ip tftp get test Sent 159 bytes in 0.0 seconds tftp quit cat test BusyBox Disk Remount SD Card for clear Read-only Flag Use sudo fdisk -l for show all disk Remount SD Card with folow command: sudo mount /dev/sdc -o remount,rw","title":"Tips"},{"location":"technote/tips/tips/#ssh-for-remote-control","text":"Secure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line login and remote command execution , but any network service can be secured with SSH. Advanced options Disable host key checking: ssh -o StrictHostKeyChecking=no Redirect known host file (~/.ssh/known_hosts) to /dev/null: ssh -o UserKnownHostsFile=/dev/null Execute scripts in remote machine: ssh user@host 'ENDSSH' #commands to run on remote host ENDSSH Example ssh root@10.61.61.195 \"echo 1 ~/test\" . This command will remote to root@10.61.61.195 machine and then execute \"echo 1 ~/test\" Auto-generate password for ssh echo #!/bin/sh /tmp/genpass.sh echo echo $pass /tmp/genpass.sh export SSH_ASKPASS= /tmp/genpass.sh export DISPLAY= setsid ssh root@10.61.61.195 ? setsid: what is this? See more at Bash Script SSH Automation Without a Password Prompt . Example commands timeout 20 setsid ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null References More information about SSH config can be found at https://linux.die.net/man/5/ssh_config","title":"SSH for remote control"},{"location":"technote/tips/tips/#tftp-server","text":"Trivial File Transfer Protocol (TFTP) is a simple lockstep File Transfer Protocol which allows a client to get a file from or put a file onto a remote host ( Wiki ). TFTP uses UDP as its transport protocol. Install TFTP server With Ubuntu machine, install tftp by installing following packages: sudo apt-get install xinetd tftpd tftp Build tftp server for embedded system: How to build? Configure TFTP server Create /etc/xinetd.d/tftp and put this entry service tftp { protocol = udp port = 69 socket_type = dgram wait = yes user = nobody server = /usr/sbin/in.tftpd server_args = /tftpboot disable = no } Create a folder /tftpboot this should match whatever you gave in server_args. mostly it will be tftpboot sudo mkdir /tftpboot sudo chmod -R 777 /tftpboot sudo chown -R nobody /tftpboot Restart the xinetd service. newer systems: sudo service xinetd restart older systems: sudo /etc/init.d/xinetd restart Testing tftp server Create a file named test with some content in /tftpboot path of the tftp server. Obtain the ip address of the tftp server using ifconfig command. Now in some other system (client - which want to get file) follow the following steps. tftp 192.168.1.2 # tftp server ip tftp get test Sent 159 bytes in 0.0 seconds tftp quit cat test","title":"TFTP Server"},{"location":"technote/tips/tips/#busybox","text":"","title":"BusyBox"},{"location":"technote/tips/tips/#disk","text":"Remount SD Card for clear Read-only Flag Use sudo fdisk -l for show all disk Remount SD Card with folow command: sudo mount /dev/sdc -o remount,rw","title":"Disk"},{"location":"technote/version_control/verctl/","text":"Version Control Information Version Control Client-Server Model In the client-server model, developers use a shared single repository. Subversion - SVN is a software versioning and revision control system distributed as open source under the Apache License. IBM Rational Team Concert Distributed Model In the distributed approach, each developer works directly with his or her own local repository, and changes are shared between repositories as a separate step. Git and Mercurcial (/m\u025c\u02d0r\u02c8kj\u028ari\u0259l/) are most popular version control tool. Web-based version control hosting services Github Gitlab Bitbucket Comparison from wiki: https://en.wikipedia.org/wiki/Comparison_of_source-code-hosting_facilities","title":"Version Control"},{"location":"technote/version_control/verctl/#version-control-information","text":"","title":"Version Control Information"},{"location":"technote/version_control/verctl/#version-control","text":"","title":"Version Control"},{"location":"technote/version_control/verctl/#client-server-model","text":"In the client-server model, developers use a shared single repository. Subversion - SVN is a software versioning and revision control system distributed as open source under the Apache License. IBM Rational Team Concert","title":"Client-Server Model"},{"location":"technote/version_control/verctl/#distributed-model","text":"In the distributed approach, each developer works directly with his or her own local repository, and changes are shared between repositories as a separate step. Git and Mercurcial (/m\u025c\u02d0r\u02c8kj\u028ari\u0259l/) are most popular version control tool.","title":"Distributed Model"},{"location":"technote/version_control/verctl/#web-based-version-control-hosting-services","text":"Github Gitlab Bitbucket Comparison from wiki: https://en.wikipedia.org/wiki/Comparison_of_source-code-hosting_facilities","title":"Web-based version control hosting services"}]}